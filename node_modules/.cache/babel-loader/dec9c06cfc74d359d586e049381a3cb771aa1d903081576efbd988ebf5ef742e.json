{"ast":null,"code":"var _jsxFileName = \"/Users/dbroxton/Documents/Projects/soccer-management-app/src/context/AuthContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport { onAuthStateChanged, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, updateEmail, EmailAuthProvider, reauthenticateWithCredential } from \"firebase/auth\";\nimport { doc, getDoc, setDoc, updateDoc, collection, addDoc, getDocs, deleteDoc, query, where, arrayUnion, arrayRemove, orderBy, serverTimestamp } from \"firebase/firestore\";\n// NEW: Storage imports\nimport { ref, uploadBytes, getDownloadURL } from \"firebase/storage\";\nimport { auth, db, storage } from \"../firebase\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AuthContext = /*#__PURE__*/createContext();\nexport const useAuth = () => {\n  _s();\n  return useContext(AuthContext);\n};\n_s(useAuth, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const AuthProvider = ({\n  children\n}) => {\n  _s2();\n  const [loggedInUser, setLoggedInUser] = useState(null);\n  const [soccerDetails, setSoccerDetails] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [needsReauth, setNeedsReauth] = useState(false);\n  useEffect(() => {\n    const unsubscribe = onAuthStateChanged(auth, async user => {\n      if (user) {\n        const userDocRef = doc(db, \"users\", user.uid);\n        const userDoc = await getDoc(userDocRef);\n        const soccerDocRef = doc(db, \"users\", user.uid, \"sportsDetails\", \"soccer\");\n        const soccerDoc = await getDoc(soccerDocRef);\n        if (userDoc.exists()) {\n          setLoggedInUser(userDoc.data());\n        } else {\n          setLoggedInUser(null);\n        }\n        if (soccerDoc.exists()) {\n          setSoccerDetails(soccerDoc.data());\n        } else {\n          setSoccerDetails(null);\n        }\n      } else {\n        setLoggedInUser(null);\n        setSoccerDetails(null);\n      }\n      setIsLoading(false);\n    });\n    return () => unsubscribe();\n  }, []);\n  const signIn = async (email, password) => {\n    setIsLoading(true);\n    try {\n      const userCredential = await signInWithEmailAndPassword(auth, email, password);\n      const user = userCredential.user;\n      const userDocRef = doc(db, \"users\", user.uid);\n      const userDoc = await getDoc(userDocRef);\n      const soccerDocRef = doc(db, \"users\", user.uid, \"sportsDetails\", \"soccer\");\n      const soccerDoc = await getDoc(soccerDocRef);\n      if (soccerDoc.exists()) {\n        setSoccerDetails(soccerDoc.data());\n      } else {\n        setSoccerDetails(null);\n      }\n      if (userDoc.exists()) {\n        setLoggedInUser(userDoc.data());\n      } else {\n        alert(\"Authentication successful, but no profile was found.\");\n        setLoggedInUser(null);\n      }\n    } catch (error) {\n      console.error(\"Error signing in:\", error);\n      alert(\"Error: \" + error.message);\n    }\n    setIsLoading(false);\n  };\n  const signUp = async formData => {\n    if (formData.password.length < 6) {\n      alert(\"Password must be at least 6 characters long.\");\n      return;\n    }\n    try {\n      const userCredential = await createUserWithEmailAndPassword(auth, formData.email, formData.password);\n      const user = userCredential.user;\n      const userProfileData = {\n        uid: user.uid,\n        playerName: formData.playerName,\n        email: formData.email,\n        phone: formData.phone,\n        address: formData.address,\n        notificationPreference: formData.notificationPreference,\n        comments: formData.comments,\n        role: 'player'\n      };\n      await setDoc(doc(db, \"users\", user.uid), userProfileData);\n      setLoggedInUser(userProfileData);\n    } catch (error) {\n      console.error(\"Error signing up:\", error);\n      alert(\"Error: \" + error.message);\n    }\n  };\n  const signOutUser = async () => {\n    try {\n      await signOut(auth);\n      setLoggedInUser(null);\n      setSoccerDetails(null);\n    } catch (error) {\n      console.error(\"Error signing out:\", error);\n      alert(\"Error: \" + error.message);\n    }\n  };\n  const updateProfile = async profileData => {\n    if (!loggedInUser) return;\n    if (profileData.email !== loggedInUser.email) {\n      try {\n        await updateEmail(auth.currentUser, profileData.email);\n      } catch (error) {\n        if (error.code === 'auth/requires-recent-login') {\n          setNeedsReauth(true);\n        } else {\n          alert(\"Error: \" + error.message);\n        }\n        return;\n      }\n    }\n    try {\n      const dataToUpdate = {\n        playerName: profileData.playerName,\n        phone: profileData.phone,\n        address: profileData.address,\n        notificationPreference: profileData.notificationPreference,\n        comments: profileData.comments,\n        email: profileData.email\n      };\n      const userDocRef = doc(db, \"users\", loggedInUser.uid);\n      await updateDoc(userDocRef, dataToUpdate);\n      setLoggedInUser(prevUser => ({\n        ...prevUser,\n        ...dataToUpdate\n      }));\n      alert(\"Profile successfully updated!\");\n      return true;\n    } catch (error) {\n      alert(\"Error saving profile: \" + error.message);\n      return false;\n    }\n  };\n  const reauthenticate = async (password, newEmail) => {\n    if (!auth.currentUser || !password) return;\n    try {\n      const credential = EmailAuthProvider.credential(auth.currentUser.email, password);\n      await reauthenticateWithCredential(auth.currentUser, credential);\n      await updateEmail(auth.currentUser, newEmail);\n      const userDocRef = doc(db, \"users\", loggedInUser.uid);\n      await updateDoc(userDocRef, {\n        email: newEmail\n      });\n      setLoggedInUser(prevUser => ({\n        ...prevUser,\n        email: newEmail\n      }));\n      alert(\"Email successfully updated!\");\n      setNeedsReauth(false);\n      return true;\n    } catch (error) {\n      alert(\"Error: Incorrect password or another error occurred. \" + error.message);\n      return false;\n    }\n  };\n  const updateSoccerDetails = async soccerData => {\n    if (!loggedInUser) return;\n    try {\n      const soccerDataToSave = {\n        ...soccerData,\n        currentRosters: soccerData.currentRosters.split(',').map(item => item.trim()),\n        rosterJerseysOwned: soccerData.rosterJerseysOwned.split(',').map(item => item.trim()),\n        playerNumber: Number(soccerData.playerNumber) || 0\n      };\n      const soccerDocRef = doc(db, \"users\", loggedInUser.uid, \"sportsDetails\", \"soccer\");\n      await setDoc(soccerDocRef, soccerDataToSave);\n      setSoccerDetails(soccerDataToSave);\n      alert(\"Soccer info saved!\");\n      return true;\n    } catch (error) {\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const isManager = () => {\n    return loggedInUser && loggedInUser.role === 'manager';\n  };\n  const createRoster = async (rosterName, season, maxCapacity) => {\n    if (!isManager()) {\n      alert(\"Only managers can create rosters.\");\n      return false;\n    }\n    try {\n      const rosterRef = await addDoc(collection(db, \"rosters\"), {\n        name: rosterName,\n        season: season,\n        maxCapacity: Number(maxCapacity),\n        createdBy: loggedInUser.uid,\n        createdAt: new Date(),\n        playerIDs: [],\n        players: []\n      });\n      await addDoc(collection(db, \"chats\"), {\n        type: 'roster',\n        rosterId: rosterRef.id,\n        name: `${rosterName} (${season})`,\n        participants: [loggedInUser.uid],\n        visibleTo: [loggedInUser.uid],\n        participantDetails: [{\n          uid: loggedInUser.uid,\n          name: loggedInUser.playerName,\n          email: loggedInUser.email\n        }],\n        createdAt: serverTimestamp(),\n        lastMessage: \"Team chat created\",\n        lastMessageTime: serverTimestamp()\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating roster:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const fetchRosters = async () => {\n    try {\n      const querySnapshot = await getDocs(collection(db, \"rosters\"));\n      return querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error(\"Error fetching rosters:\", error);\n      return [];\n    }\n  };\n  const deleteRoster = async rosterId => {\n    if (!isManager()) return false;\n    try {\n      await deleteDoc(doc(db, \"rosters\", rosterId));\n      return true;\n    } catch (error) {\n      console.error(\"Error deleting roster:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const addPlayerToRoster = async (rosterId, playerEmail) => {\n    if (!isManager()) return false;\n    try {\n      const usersRef = collection(db, \"users\");\n      const q = query(usersRef, where(\"email\", \"==\", playerEmail));\n      const querySnapshot = await getDocs(q);\n      if (querySnapshot.empty) {\n        alert(\"No player found with that email address.\");\n        return false;\n      }\n      const playerDoc = querySnapshot.docs[0];\n      const playerData = playerDoc.data();\n      const playerSummary = {\n        uid: playerDoc.id,\n        playerName: playerData.playerName || \"Unknown\",\n        email: playerData.email\n      };\n      const rosterRef = doc(db, \"rosters\", rosterId);\n      await updateDoc(rosterRef, {\n        playerIDs: arrayUnion(playerDoc.id),\n        players: arrayUnion(playerSummary)\n      });\n      const chatsRef = collection(db, \"chats\");\n      const chatQ = query(chatsRef, where(\"rosterId\", \"==\", rosterId));\n      const chatSnapshot = await getDocs(chatQ);\n      if (!chatSnapshot.empty) {\n        const chatDoc = chatSnapshot.docs[0];\n        await updateDoc(chatDoc.ref, {\n          participants: arrayUnion(playerDoc.id),\n          visibleTo: arrayUnion(playerDoc.id),\n          participantDetails: arrayUnion(playerSummary)\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Error adding player:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const removePlayerFromRoster = async (rosterId, playerSummary) => {\n    if (!isManager()) return false;\n    try {\n      const rosterRef = doc(db, \"rosters\", rosterId);\n      await updateDoc(rosterRef, {\n        playerIDs: arrayRemove(playerSummary.uid),\n        players: arrayRemove(playerSummary)\n      });\n      const chatsRef = collection(db, \"chats\");\n      const chatQ = query(chatsRef, where(\"rosterId\", \"==\", rosterId));\n      const chatSnapshot = await getDocs(chatQ);\n      if (!chatSnapshot.empty) {\n        const chatDoc = chatSnapshot.docs[0];\n        await updateDoc(chatDoc.ref, {\n          participants: arrayRemove(playerSummary.uid),\n          visibleTo: arrayRemove(playerSummary.uid),\n          participantDetails: arrayRemove(playerSummary)\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Error removing player:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const fetchUserRosters = async uid => {\n    try {\n      const rostersRef = collection(db, \"rosters\");\n      const q = query(rostersRef, where(\"playerIDs\", \"array-contains\", uid));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error(\"Error fetching user rosters:\", error);\n      return [];\n    }\n  };\n  const createEvent = async (rosterId, eventData) => {\n    try {\n      await addDoc(collection(db, \"rosters\", rosterId, \"events\"), {\n        ...eventData,\n        createdAt: new Date()\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating event:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const fetchEvents = async rosterId => {\n    try {\n      const eventsRef = collection(db, \"rosters\", rosterId, \"events\");\n      const q = query(eventsRef, orderBy(\"dateTime\", \"asc\"));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error(\"Error fetching events:\", error);\n      return [];\n    }\n  };\n  const deleteEvent = async (rosterId, eventId) => {\n    if (!isManager()) return false;\n    try {\n      await deleteDoc(doc(db, \"rosters\", rosterId, \"events\", eventId));\n      return true;\n    } catch (error) {\n      console.error(\"Error deleting event:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const fetchAllUserEvents = async uid => {\n    try {\n      const rosters = await fetchUserRosters(uid);\n      let allEvents = [];\n      for (const roster of rosters) {\n        const eventsRef = collection(db, \"rosters\", roster.id, \"events\");\n        const q = query(eventsRef);\n        const querySnapshot = await getDocs(q);\n        const rosterEvents = querySnapshot.docs.map(doc => ({\n          id: doc.id,\n          rosterName: roster.name,\n          ...doc.data()\n        }));\n        allEvents = [...allEvents, ...rosterEvents];\n      }\n      allEvents.sort((a, b) => new Date(a.dateTime) - new Date(b.dateTime));\n      return allEvents;\n    } catch (error) {\n      console.error(\"Error fetching all events:\", error);\n      return [];\n    }\n  };\n\n  // --- NEW: Upload Image Function ---\n  const uploadImage = async (file, path) => {\n    if (!file) return null;\n    try {\n      const storageRef = ref(storage, `${path}/${Date.now()}_${file.name}`);\n      const snapshot = await uploadBytes(storageRef, file);\n      const downloadURL = await getDownloadURL(snapshot.ref);\n      return downloadURL;\n    } catch (error) {\n      console.error(\"Error uploading image:\", error);\n      throw error;\n    }\n  };\n  const createChat = async (participantEmails, chatName = \"\") => {\n    try {\n      const usersRef = collection(db, \"users\");\n      const participants = [];\n      const participantIds = [loggedInUser.uid];\n      participants.push({\n        uid: loggedInUser.uid,\n        name: loggedInUser.playerName,\n        email: loggedInUser.email\n      });\n      for (const email of participantEmails) {\n        if (email === loggedInUser.email) continue;\n        const q = query(usersRef, where(\"email\", \"==\", email));\n        const snapshot = await getDocs(q);\n        if (!snapshot.empty) {\n          const userDoc = snapshot.docs[0];\n          const userData = userDoc.data();\n          participantIds.push(userDoc.id);\n          participants.push({\n            uid: userDoc.id,\n            name: userData.playerName || \"Unknown\",\n            email: userData.email\n          });\n        }\n      }\n      if (participantIds.length < 2) {\n        alert(\"Could not find any valid users to chat with.\");\n        return false;\n      }\n      await addDoc(collection(db, \"chats\"), {\n        type: participantIds.length > 2 ? 'group' : 'dm',\n        name: chatName || (participants.length === 2 ? participants[1].name : \"Group Chat\"),\n        participants: participantIds,\n        visibleTo: participantIds,\n        participantDetails: participants,\n        createdAt: serverTimestamp(),\n        lastMessage: \"Chat created\",\n        lastMessageTime: serverTimestamp()\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating chat:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  // --- UPDATED: Send Message ---\n  const sendMessage = async (chatId, text, currentParticipants, imageUrl = null) => {\n    try {\n      await addDoc(collection(db, \"chats\", chatId, \"messages\"), {\n        text: text,\n        imageUrl: imageUrl,\n        // Store the URL\n        senderId: loggedInUser.uid,\n        senderName: loggedInUser.playerName,\n        createdAt: serverTimestamp()\n      });\n\n      // Update parent chat doc\n      const chatRef = doc(db, \"chats\", chatId);\n\n      // Construct summary text\n      let summary = text;\n      if (imageUrl) {\n        summary = text ? `ðŸ“· ${text}` : \"ðŸ“· Sent an image\";\n      }\n      await updateDoc(chatRef, {\n        lastMessage: summary,\n        lastMessageTime: serverTimestamp(),\n        visibleTo: currentParticipants\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error sending message:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const fetchUserChats = async uid => {\n    try {\n      const chatsRef = collection(db, \"chats\");\n      const q = query(chatsRef, where(\"visibleTo\", \"array-contains\", uid), orderBy(\"lastMessageTime\", \"desc\"));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error(\"Error fetching chats:\", error);\n      return [];\n    }\n  };\n  const hideChat = async (chatId, currentVisibleTo, chatType) => {\n    if (chatType === 'roster') {\n      alert(\"Team Roster chats cannot be deleted.\");\n      return false;\n    }\n    try {\n      const newVisibleTo = currentVisibleTo.filter(uid => uid !== loggedInUser.uid);\n      if (newVisibleTo.length === 0) {\n        await deleteDoc(doc(db, \"chats\", chatId));\n      } else {\n        const chatRef = doc(db, \"chats\", chatId);\n        await updateDoc(chatRef, {\n          visibleTo: newVisibleTo\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Error hiding chat:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const createGroup = async groupData => {\n    try {\n      await addDoc(collection(db, \"groups\"), {\n        ...groupData,\n        createdBy: loggedInUser.uid,\n        createdAt: serverTimestamp(),\n        members: [loggedInUser.uid],\n        // Creator is first member\n        memberDetails: [{\n          uid: loggedInUser.uid,\n          name: loggedInUser.playerName,\n          email: loggedInUser.email\n        }]\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating group:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const fetchUserGroups = async uid => {\n    try {\n      const groupsRef = collection(db, \"groups\");\n      const q = query(groupsRef, where(\"members\", \"array-contains\", uid));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error(\"Error fetching groups:\", error);\n      return [];\n    }\n  };\n  const createGroupPost = async (groupId, text, imageUrl = null) => {\n    try {\n      await addDoc(collection(db, \"groups\", groupId, \"posts\"), {\n        text: text,\n        imageUrl: imageUrl,\n        authorId: loggedInUser.uid,\n        authorName: loggedInUser.playerName,\n        createdAt: serverTimestamp(),\n        replies: [] // Initialize empty replies array\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating post:\", error);\n      return false;\n    }\n  };\n  const addGroupMembers = async (groupId, emails) => {\n    try {\n      const usersRef = collection(db, \"users\");\n      const newMembers = [];\n      const newMemberIds = [];\n      for (const email of emails) {\n        // Avoid adding self again or existing members logic handled by caller or Firestore set (arrayUnion handles uniqueness)\n        const q = query(usersRef, where(\"email\", \"==\", email));\n        const snapshot = await getDocs(q);\n        if (!snapshot.empty) {\n          const userDoc = snapshot.docs[0];\n          const userData = userDoc.data();\n          newMemberIds.push(userDoc.id);\n          newMembers.push({\n            uid: userDoc.id,\n            name: userData.playerName || \"Unknown\",\n            email: userData.email\n          });\n        }\n      }\n      if (newMemberIds.length === 0) {\n        return false; // No valid users found\n      }\n      const groupRef = doc(db, \"groups\", groupId);\n\n      // We use arrayUnion to add new items without overwriting\n      // Note: For memberDetails array of objects, exact object match is required for uniqueness. \n      // This is generally okay here since we construct it consistently.\n      await updateDoc(groupRef, {\n        members: arrayUnion(...newMemberIds),\n        memberDetails: arrayUnion(...newMembers)\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error adding group members:\", error);\n      alert(\"Error adding members: \" + error.message);\n      return false;\n    }\n  };\n  const value = {\n    // ... (All existing exports) ...\n    loggedInUser,\n    soccerDetails,\n    isLoading,\n    needsReauth,\n    setNeedsReauth,\n    signIn,\n    signUp,\n    signOutUser,\n    updateProfile,\n    reauthenticate,\n    updateSoccerDetails,\n    isManager,\n    createRoster,\n    fetchRosters,\n    deleteRoster,\n    addPlayerToRoster,\n    removePlayerFromRoster,\n    fetchUserRosters,\n    createEvent,\n    fetchEvents,\n    deleteEvent,\n    fetchAllUserEvents,\n    createChat,\n    sendMessage,\n    fetchUserChats,\n    hideChat,\n    uploadImage,\n    createGroup,\n    fetchUserGroups,\n    createGroupPost,\n    // NEW: Export addGroupMembers\n    addGroupMembers\n  };\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 703,\n    columnNumber: 5\n  }, this);\n};\n_s2(AuthProvider, \"5MPytths2y1fFmqpbAcpPs27WVo=\");\n_c = AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","onAuthStateChanged","signInWithEmailAndPassword","createUserWithEmailAndPassword","signOut","updateEmail","EmailAuthProvider","reauthenticateWithCredential","doc","getDoc","setDoc","updateDoc","collection","addDoc","getDocs","deleteDoc","query","where","arrayUnion","arrayRemove","orderBy","serverTimestamp","ref","uploadBytes","getDownloadURL","auth","db","storage","jsxDEV","_jsxDEV","AuthContext","useAuth","_s","AuthProvider","children","_s2","loggedInUser","setLoggedInUser","soccerDetails","setSoccerDetails","isLoading","setIsLoading","needsReauth","setNeedsReauth","unsubscribe","user","userDocRef","uid","userDoc","soccerDocRef","soccerDoc","exists","data","signIn","email","password","userCredential","alert","error","console","message","signUp","formData","length","userProfileData","playerName","phone","address","notificationPreference","comments","role","signOutUser","updateProfile","profileData","currentUser","code","dataToUpdate","prevUser","reauthenticate","newEmail","credential","updateSoccerDetails","soccerData","soccerDataToSave","currentRosters","split","map","item","trim","rosterJerseysOwned","playerNumber","Number","isManager","createRoster","rosterName","season","maxCapacity","rosterRef","name","createdBy","createdAt","Date","playerIDs","players","type","rosterId","id","participants","visibleTo","participantDetails","lastMessage","lastMessageTime","fetchRosters","querySnapshot","docs","deleteRoster","addPlayerToRoster","playerEmail","usersRef","q","empty","playerDoc","playerData","playerSummary","chatsRef","chatQ","chatSnapshot","chatDoc","removePlayerFromRoster","fetchUserRosters","rostersRef","createEvent","eventData","fetchEvents","eventsRef","deleteEvent","eventId","fetchAllUserEvents","rosters","allEvents","roster","rosterEvents","sort","a","b","dateTime","uploadImage","file","path","storageRef","now","snapshot","downloadURL","createChat","participantEmails","chatName","participantIds","push","userData","sendMessage","chatId","text","currentParticipants","imageUrl","senderId","senderName","chatRef","summary","fetchUserChats","hideChat","currentVisibleTo","chatType","newVisibleTo","filter","createGroup","groupData","members","memberDetails","fetchUserGroups","groupsRef","createGroupPost","groupId","authorId","authorName","replies","addGroupMembers","emails","newMembers","newMemberIds","groupRef","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/dbroxton/Documents/Projects/soccer-management-app/src/context/AuthContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect } from 'react';\nimport {\n  onAuthStateChanged,\n  signInWithEmailAndPassword,\n  createUserWithEmailAndPassword,\n  signOut,\n  updateEmail,\n  EmailAuthProvider,\n  reauthenticateWithCredential\n} from \"firebase/auth\";\nimport { \n  doc, getDoc, setDoc, updateDoc, collection, addDoc, getDocs, deleteDoc, \n  query, where, arrayUnion, arrayRemove, orderBy, serverTimestamp \n} from \"firebase/firestore\";\n// NEW: Storage imports\nimport { ref, uploadBytes, getDownloadURL } from \"firebase/storage\";\nimport { auth, db, storage } from \"../firebase\"; \n\nconst AuthContext = createContext();\n\nexport const useAuth = () => {\n  return useContext(AuthContext);\n};\n\nexport const AuthProvider = ({ children }) => {\n  const [loggedInUser, setLoggedInUser] = useState(null);\n  const [soccerDetails, setSoccerDetails] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [needsReauth, setNeedsReauth] = useState(false);\n\n  useEffect(() => {\n    const unsubscribe = onAuthStateChanged(auth, async (user) => {\n      if (user) {\n        const userDocRef = doc(db, \"users\", user.uid);\n        const userDoc = await getDoc(userDocRef);\n        const soccerDocRef = doc(db, \"users\", user.uid, \"sportsDetails\", \"soccer\");\n        const soccerDoc = await getDoc(soccerDocRef);\n\n        if (userDoc.exists()) {\n          setLoggedInUser(userDoc.data());\n        } else {\n          setLoggedInUser(null);\n        }\n\n        if (soccerDoc.exists()) {\n          setSoccerDetails(soccerDoc.data());\n        } else {\n          setSoccerDetails(null);\n        }\n      } else {\n        setLoggedInUser(null);\n        setSoccerDetails(null);\n      }\n      setIsLoading(false);\n    });\n\n    return () => unsubscribe();\n  }, []); \n\n  const signIn = async (email, password) => {\n    setIsLoading(true);\n    try {\n      const userCredential = await signInWithEmailAndPassword(auth, email, password);\n      const user = userCredential.user;\n      \n      const userDocRef = doc(db, \"users\", user.uid);\n      const userDoc = await getDoc(userDocRef);\n      const soccerDocRef = doc(db, \"users\", user.uid, \"sportsDetails\", \"soccer\");\n      const soccerDoc = await getDoc(soccerDocRef);\n\n      if (soccerDoc.exists()) {\n        setSoccerDetails(soccerDoc.data());\n      } else {\n        setSoccerDetails(null);\n      }\n\n      if (userDoc.exists()) {\n        setLoggedInUser(userDoc.data());\n      } else {\n        alert(\"Authentication successful, but no profile was found.\");\n        setLoggedInUser(null);\n      }\n    } catch (error) {\n      console.error(\"Error signing in:\", error);\n      alert(\"Error: \" + error.message);\n    }\n    setIsLoading(false);\n  };\n\n  const signUp = async (formData) => {\n    if (formData.password.length < 6) {\n      alert(\"Password must be at least 6 characters long.\");\n      return;\n    }\n    try {\n      const userCredential = await createUserWithEmailAndPassword(auth, formData.email, formData.password);\n      const user = userCredential.user;\n      \n      const userProfileData = {\n        uid: user.uid,\n        playerName: formData.playerName,\n        email: formData.email,\n        phone: formData.phone,\n        address: formData.address,\n        notificationPreference: formData.notificationPreference,\n        comments: formData.comments,\n        role: 'player'\n      };\n      \n      await setDoc(doc(db, \"users\", user.uid), userProfileData);\n      setLoggedInUser(userProfileData);\n    } catch (error) {\n      console.error(\"Error signing up:\", error);\n      alert(\"Error: \" + error.message);\n    }\n  };\n\n  const signOutUser = async () => {\n    try {\n      await signOut(auth);\n      setLoggedInUser(null);\n      setSoccerDetails(null);\n    } catch (error) {\n      console.error(\"Error signing out:\", error);\n      alert(\"Error: \" + error.message);\n    }\n  };\n\n  const updateProfile = async (profileData) => {\n    if (!loggedInUser) return;\n    if (profileData.email !== loggedInUser.email) {\n      try {\n        await updateEmail(auth.currentUser, profileData.email);\n      } catch (error) {\n        if (error.code === 'auth/requires-recent-login') {\n          setNeedsReauth(true); \n        } else {\n          alert(\"Error: \" + error.message);\n        }\n        return;\n      }\n    }\n    try {\n      const dataToUpdate = {\n        playerName: profileData.playerName,\n        phone: profileData.phone,\n        address: profileData.address,\n        notificationPreference: profileData.notificationPreference,\n        comments: profileData.comments,\n        email: profileData.email\n      };\n      \n      const userDocRef = doc(db, \"users\", loggedInUser.uid);\n      await updateDoc(userDocRef, dataToUpdate);\n      \n      setLoggedInUser(prevUser => ({\n        ...prevUser,\n        ...dataToUpdate\n      }));\n      \n      alert(\"Profile successfully updated!\");\n      return true; \n    } catch (error) {\n      alert(\"Error saving profile: \" + error.message);\n      return false;\n    }\n  };\n\n  const reauthenticate = async (password, newEmail) => {\n    if (!auth.currentUser || !password) return;\n    try {\n      const credential = EmailAuthProvider.credential(auth.currentUser.email, password);\n      await reauthenticateWithCredential(auth.currentUser, credential);\n      await updateEmail(auth.currentUser, newEmail);\n      const userDocRef = doc(db, \"users\", loggedInUser.uid);\n      await updateDoc(userDocRef, { email: newEmail });\n\n      setLoggedInUser(prevUser => ({\n        ...prevUser,\n        email: newEmail\n      }));\n\n      alert(\"Email successfully updated!\");\n      setNeedsReauth(false); \n      return true; \n    } catch (error) {\n      alert(\"Error: Incorrect password or another error occurred. \" + error.message);\n      return false;\n    }\n  };\n\n  const updateSoccerDetails = async (soccerData) => {\n    if (!loggedInUser) return;\n    try {\n      const soccerDataToSave = {\n        ...soccerData,\n        currentRosters: soccerData.currentRosters.split(',').map(item => item.trim()),\n        rosterJerseysOwned: soccerData.rosterJerseysOwned.split(',').map(item => item.trim()),\n        playerNumber: Number(soccerData.playerNumber) || 0,\n      };\n      \n      const soccerDocRef = doc(db, \"users\", loggedInUser.uid, \"sportsDetails\", \"soccer\");\n      await setDoc(soccerDocRef, soccerDataToSave);\n      \n      setSoccerDetails(soccerDataToSave); \n      alert(\"Soccer info saved!\");\n      return true; \n\n    } catch (error) {\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const isManager = () => {\n    return loggedInUser && loggedInUser.role === 'manager';\n  };\n\n  const createRoster = async (rosterName, season, maxCapacity) => {\n    if (!isManager()) {\n      alert(\"Only managers can create rosters.\");\n      return false;\n    }\n    try {\n      const rosterRef = await addDoc(collection(db, \"rosters\"), {\n        name: rosterName,\n        season: season,\n        maxCapacity: Number(maxCapacity),\n        createdBy: loggedInUser.uid,\n        createdAt: new Date(),\n        playerIDs: [],\n        players: [] \n      });\n\n      await addDoc(collection(db, \"chats\"), {\n        type: 'roster', \n        rosterId: rosterRef.id,\n        name: `${rosterName} (${season})`,\n        participants: [loggedInUser.uid],\n        visibleTo: [loggedInUser.uid],\n        participantDetails: [{\n          uid: loggedInUser.uid,\n          name: loggedInUser.playerName,\n          email: loggedInUser.email\n        }],\n        createdAt: serverTimestamp(),\n        lastMessage: \"Team chat created\",\n        lastMessageTime: serverTimestamp()\n      });\n\n      return true;\n    } catch (error) {\n      console.error(\"Error creating roster:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const fetchRosters = async () => {\n    try {\n      const querySnapshot = await getDocs(collection(db, \"rosters\"));\n      return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n    } catch (error) {\n      console.error(\"Error fetching rosters:\", error);\n      return [];\n    }\n  };\n\n  const deleteRoster = async (rosterId) => {\n    if (!isManager()) return false;\n    try {\n      await deleteDoc(doc(db, \"rosters\", rosterId));\n      return true;\n    } catch (error) {\n      console.error(\"Error deleting roster:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const addPlayerToRoster = async (rosterId, playerEmail) => {\n    if (!isManager()) return false;\n    try {\n      const usersRef = collection(db, \"users\");\n      const q = query(usersRef, where(\"email\", \"==\", playerEmail));\n      const querySnapshot = await getDocs(q);\n\n      if (querySnapshot.empty) {\n        alert(\"No player found with that email address.\");\n        return false;\n      }\n\n      const playerDoc = querySnapshot.docs[0];\n      const playerData = playerDoc.data();\n\n      const playerSummary = {\n        uid: playerDoc.id,\n        playerName: playerData.playerName || \"Unknown\",\n        email: playerData.email\n      };\n\n      const rosterRef = doc(db, \"rosters\", rosterId);\n      await updateDoc(rosterRef, {\n        playerIDs: arrayUnion(playerDoc.id),\n        players: arrayUnion(playerSummary) \n      });\n\n      const chatsRef = collection(db, \"chats\");\n      const chatQ = query(chatsRef, where(\"rosterId\", \"==\", rosterId));\n      const chatSnapshot = await getDocs(chatQ);\n\n      if (!chatSnapshot.empty) {\n        const chatDoc = chatSnapshot.docs[0];\n        await updateDoc(chatDoc.ref, {\n          participants: arrayUnion(playerDoc.id),\n          visibleTo: arrayUnion(playerDoc.id),\n          participantDetails: arrayUnion(playerSummary)\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Error adding player:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const removePlayerFromRoster = async (rosterId, playerSummary) => {\n    if (!isManager()) return false;\n    try {\n      const rosterRef = doc(db, \"rosters\", rosterId);\n      await updateDoc(rosterRef, {\n        playerIDs: arrayRemove(playerSummary.uid),\n        players: arrayRemove(playerSummary)\n      });\n\n      const chatsRef = collection(db, \"chats\");\n      const chatQ = query(chatsRef, where(\"rosterId\", \"==\", rosterId));\n      const chatSnapshot = await getDocs(chatQ);\n\n      if (!chatSnapshot.empty) {\n        const chatDoc = chatSnapshot.docs[0];\n        await updateDoc(chatDoc.ref, {\n          participants: arrayRemove(playerSummary.uid),\n          visibleTo: arrayRemove(playerSummary.uid),\n          participantDetails: arrayRemove(playerSummary)\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Error removing player:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const fetchUserRosters = async (uid) => {\n    try {\n      const rostersRef = collection(db, \"rosters\");\n      const q = query(rostersRef, where(\"playerIDs\", \"array-contains\", uid));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n    } catch (error) {\n      console.error(\"Error fetching user rosters:\", error);\n      return [];\n    }\n  };\n\n  const createEvent = async (rosterId, eventData) => {\n    try {\n      await addDoc(collection(db, \"rosters\", rosterId, \"events\"), {\n        ...eventData,\n        createdAt: new Date()\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating event:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const fetchEvents = async (rosterId) => {\n    try {\n      const eventsRef = collection(db, \"rosters\", rosterId, \"events\");\n      const q = query(eventsRef, orderBy(\"dateTime\", \"asc\"));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n    } catch (error) {\n      console.error(\"Error fetching events:\", error);\n      return [];\n    }\n  };\n\n  const deleteEvent = async (rosterId, eventId) => {\n    if (!isManager()) return false;\n    try {\n      await deleteDoc(doc(db, \"rosters\", rosterId, \"events\", eventId));\n      return true;\n    } catch (error) {\n      console.error(\"Error deleting event:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const fetchAllUserEvents = async (uid) => {\n    try {\n      const rosters = await fetchUserRosters(uid);\n      let allEvents = [];\n\n      for (const roster of rosters) {\n        const eventsRef = collection(db, \"rosters\", roster.id, \"events\");\n        const q = query(eventsRef); \n        const querySnapshot = await getDocs(q);\n        \n        const rosterEvents = querySnapshot.docs.map(doc => ({\n          id: doc.id,\n          rosterName: roster.name, \n          ...doc.data()\n        }));\n        allEvents = [...allEvents, ...rosterEvents];\n      }\n      allEvents.sort((a, b) => new Date(a.dateTime) - new Date(b.dateTime));\n      return allEvents;\n    } catch (error) {\n      console.error(\"Error fetching all events:\", error);\n      return [];\n    }\n  };\n\n  // --- NEW: Upload Image Function ---\n  const uploadImage = async (file, path) => {\n    if (!file) return null;\n    try {\n      const storageRef = ref(storage, `${path}/${Date.now()}_${file.name}`);\n      const snapshot = await uploadBytes(storageRef, file);\n      const downloadURL = await getDownloadURL(snapshot.ref);\n      return downloadURL;\n    } catch (error) {\n      console.error(\"Error uploading image:\", error);\n      throw error;\n    }\n  };\n\n  const createChat = async (participantEmails, chatName = \"\") => {\n    try {\n      const usersRef = collection(db, \"users\");\n      const participants = [];\n      const participantIds = [loggedInUser.uid];\n\n      participants.push({\n        uid: loggedInUser.uid,\n        name: loggedInUser.playerName,\n        email: loggedInUser.email\n      });\n\n      for (const email of participantEmails) {\n        if (email === loggedInUser.email) continue; \n        const q = query(usersRef, where(\"email\", \"==\", email));\n        const snapshot = await getDocs(q);\n        if (!snapshot.empty) {\n          const userDoc = snapshot.docs[0];\n          const userData = userDoc.data();\n          participantIds.push(userDoc.id);\n          participants.push({\n            uid: userDoc.id,\n            name: userData.playerName || \"Unknown\",\n            email: userData.email\n          });\n        }\n      }\n\n      if (participantIds.length < 2) {\n        alert(\"Could not find any valid users to chat with.\");\n        return false;\n      }\n\n      await addDoc(collection(db, \"chats\"), {\n        type: participantIds.length > 2 ? 'group' : 'dm',\n        name: chatName || (participants.length === 2 ? participants[1].name : \"Group Chat\"),\n        participants: participantIds,\n        visibleTo: participantIds,\n        participantDetails: participants,\n        createdAt: serverTimestamp(),\n        lastMessage: \"Chat created\",\n        lastMessageTime: serverTimestamp()\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating chat:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  // --- UPDATED: Send Message ---\n  const sendMessage = async (chatId, text, currentParticipants, imageUrl = null) => {\n    try {\n      await addDoc(collection(db, \"chats\", chatId, \"messages\"), {\n        text: text,\n        imageUrl: imageUrl, // Store the URL\n        senderId: loggedInUser.uid,\n        senderName: loggedInUser.playerName,\n        createdAt: serverTimestamp()\n      });\n\n      // Update parent chat doc\n      const chatRef = doc(db, \"chats\", chatId);\n      \n      // Construct summary text\n      let summary = text;\n      if (imageUrl) {\n        summary = text ? `ðŸ“· ${text}` : \"ðŸ“· Sent an image\";\n      }\n\n      await updateDoc(chatRef, {\n        lastMessage: summary,\n        lastMessageTime: serverTimestamp(),\n        visibleTo: currentParticipants \n      });\n\n      return true;\n    } catch (error) {\n      console.error(\"Error sending message:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const fetchUserChats = async (uid) => {\n    try {\n      const chatsRef = collection(db, \"chats\");\n      const q = query(chatsRef, where(\"visibleTo\", \"array-contains\", uid), orderBy(\"lastMessageTime\", \"desc\"));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error(\"Error fetching chats:\", error);\n      return [];\n    }\n  };\n\n  const hideChat = async (chatId, currentVisibleTo, chatType) => {\n    if (chatType === 'roster') {\n      alert(\"Team Roster chats cannot be deleted.\");\n      return false;\n    }\n    try {\n      const newVisibleTo = currentVisibleTo.filter(uid => uid !== loggedInUser.uid);\n      if (newVisibleTo.length === 0) {\n        await deleteDoc(doc(db, \"chats\", chatId));\n      } else {\n        const chatRef = doc(db, \"chats\", chatId);\n        await updateDoc(chatRef, {\n          visibleTo: newVisibleTo\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Error hiding chat:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\nconst createGroup = async (groupData) => {\n    try {\n      await addDoc(collection(db, \"groups\"), {\n        ...groupData,\n        createdBy: loggedInUser.uid,\n        createdAt: serverTimestamp(),\n        members: [loggedInUser.uid], // Creator is first member\n        memberDetails: [{\n          uid: loggedInUser.uid,\n          name: loggedInUser.playerName,\n          email: loggedInUser.email\n        }]\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating group:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const fetchUserGroups = async (uid) => {\n    try {\n      const groupsRef = collection(db, \"groups\");\n      const q = query(groupsRef, where(\"members\", \"array-contains\", uid));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n    } catch (error) {\n      console.error(\"Error fetching groups:\", error);\n      return [];\n    }\n  };\n\n  const createGroupPost = async (groupId, text, imageUrl = null) => {\n    try {\n      await addDoc(collection(db, \"groups\", groupId, \"posts\"), {\n        text: text,\n        imageUrl: imageUrl,\n        authorId: loggedInUser.uid,\n        authorName: loggedInUser.playerName,\n        createdAt: serverTimestamp(),\n        replies: [] // Initialize empty replies array\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating post:\", error);\n      return false;\n    }\n  };\nconst addGroupMembers = async (groupId, emails) => {\n    try {\n      const usersRef = collection(db, \"users\");\n      const newMembers = [];\n      const newMemberIds = [];\n\n      for (const email of emails) {\n        // Avoid adding self again or existing members logic handled by caller or Firestore set (arrayUnion handles uniqueness)\n        const q = query(usersRef, where(\"email\", \"==\", email));\n        const snapshot = await getDocs(q);\n        \n        if (!snapshot.empty) {\n          const userDoc = snapshot.docs[0];\n          const userData = userDoc.data();\n          \n          newMemberIds.push(userDoc.id);\n          newMembers.push({\n            uid: userDoc.id,\n            name: userData.playerName || \"Unknown\",\n            email: userData.email\n          });\n        }\n      }\n\n      if (newMemberIds.length === 0) {\n        return false; // No valid users found\n      }\n\n      const groupRef = doc(db, \"groups\", groupId);\n      \n      // We use arrayUnion to add new items without overwriting\n      // Note: For memberDetails array of objects, exact object match is required for uniqueness. \n      // This is generally okay here since we construct it consistently.\n      await updateDoc(groupRef, {\n        members: arrayUnion(...newMemberIds),\n        memberDetails: arrayUnion(...newMembers)\n      });\n\n      return true;\n\n    } catch (error) {\n      console.error(\"Error adding group members:\", error);\n      alert(\"Error adding members: \" + error.message);\n      return false;\n    }\n  };\n\n\n  const value = {\n    // ... (All existing exports) ...\n    loggedInUser,\n    soccerDetails,\n    isLoading,\n    needsReauth,\n    setNeedsReauth,\n    signIn,\n    signUp,\n    signOutUser,\n    updateProfile,\n    reauthenticate,\n    updateSoccerDetails,\n    isManager,\n    createRoster,\n    fetchRosters,\n    deleteRoster,\n    addPlayerToRoster,\n    removePlayerFromRoster,\n    fetchUserRosters,\n    createEvent,\n    fetchEvents,\n    deleteEvent,\n    fetchAllUserEvents,\n    createChat,\n    sendMessage,\n    fetchUserChats,\n    hideChat,\n    uploadImage,\n    createGroup,\n    fetchUserGroups,\n    createGroupPost,\n    // NEW: Export addGroupMembers\n    addGroupMembers\n  };\n\n  return (\n    <AuthContext.Provider value={value}>\n      {children}\n    </AuthContext.Provider>\n  );\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}