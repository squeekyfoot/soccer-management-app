{"ast":null,"code":"var _jsxFileName = \"/Users/dbroxton/Documents/Projects/soccer-management-app/src/context/ChatContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport { collection, addDoc, setDoc, updateDoc, deleteDoc, doc, query, where, orderBy, onSnapshot, serverTimestamp, increment } from \"firebase/firestore\";\nimport { db } from \"../firebase\";\nimport { useAuth } from './AuthContext';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ChatContext = /*#__PURE__*/createContext();\nexport const useChat = () => {\n  _s();\n  return useContext(ChatContext);\n};\n_s(useChat, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const ChatProvider = ({\n  children\n}) => {\n  _s2();\n  const {\n    loggedInUser\n  } = useAuth();\n  const [myChats, setMyChats] = useState([]);\n\n  // 1. GLOBAL LISTENER: Fetch chats for the logged-in user\n  useEffect(() => {\n    if (!loggedInUser) {\n      setMyChats([]);\n      return;\n    }\n    const chatsRef = collection(db, \"chats\");\n    const q = query(chatsRef, where(\"visibleTo\", \"array-contains\", loggedInUser.uid), orderBy(\"lastMessageTime\", \"desc\"));\n    const unsubscribe = onSnapshot(q, snapshot => {\n      const chats = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setMyChats(chats);\n    }, error => {\n      console.error(\"Error listening to chat list:\", error);\n    });\n    return () => unsubscribe();\n  }, [loggedInUser]);\n\n  // 2. MARK READ\n  const markChatAsRead = async chatId => {\n    if (!loggedInUser) return;\n    try {\n      const chatRef = doc(db, \"chats\", chatId);\n      await updateDoc(chatRef, {\n        [`unreadCounts.${loggedInUser.uid}`]: 0\n      });\n    } catch (error) {\n      // Fallback for older documents without the field\n      try {\n        const chatRef = doc(db, \"chats\", chatId);\n        await setDoc(chatRef, {\n          unreadCounts: {\n            [loggedInUser.uid]: 0\n          }\n        }, {\n          merge: true\n        });\n      } catch (e) {\n        console.error(\"Error marking read:\", e);\n      }\n    }\n  };\n\n  // 3. CREATE CHAT\n  const createChat = async (participantEmails, chatName = \"\") => {\n    try {\n      const usersRef = collection(db, \"users\");\n      const participants = [];\n      const participantIds = [loggedInUser.uid];\n\n      // Add self\n      participants.push({\n        uid: loggedInUser.uid,\n        name: loggedInUser.playerName,\n        email: loggedInUser.email,\n        photoURL: loggedInUser.photoURL || \"\"\n      });\n\n      // Resolve other emails to Users\n      for (const email of participantEmails) {\n        if (email === loggedInUser.email) continue;\n        const q = query(usersRef, where(\"email\", \"==\", email));\n        const querySnapshot = await import(\"firebase/firestore\").then(mod => mod.getDocs(q));\n        if (!querySnapshot.empty) {\n          const userDoc = querySnapshot.docs[0];\n          const userData = userDoc.data();\n          participantIds.push(userDoc.id);\n          participants.push({\n            uid: userDoc.id,\n            name: userData.playerName || \"Unknown\",\n            email: userData.email,\n            photoURL: userData.photoURL || \"\"\n          });\n        }\n      }\n      if (participantIds.length < 2) {\n        alert(\"Could not find any valid users to chat with.\");\n        return false;\n      }\n\n      // Check for existing 1:1 or exact group match\n      // (Note: We are doing a client-side check on the 'myChats' we already loaded)\n      const existingChat = myChats.find(c => {\n        if (c.participants.length !== participantIds.length) return false;\n        return participantIds.every(id => c.participants.includes(id));\n      });\n      if (existingChat) {\n        const chatRef = doc(db, \"chats\", existingChat.id);\n        if (!existingChat.visibleTo.includes(loggedInUser.uid)) {\n          await updateDoc(chatRef, {\n            visibleTo: arrayUnion(loggedInUser.uid)\n          });\n        }\n        return {\n          id: existingChat.id,\n          participants: existingChat.participants,\n          name: existingChat.name,\n          ...existingChat\n        };\n      }\n\n      // Create New\n      const initialUnread = {};\n      participantIds.forEach(uid => initialUnread[uid] = 0);\n      const docRef = await addDoc(collection(db, \"chats\"), {\n        type: participantIds.length > 2 ? 'group' : 'dm',\n        name: chatName || (participants.length === 2 ? participants[1].name : \"Group Chat\"),\n        participants: participantIds,\n        visibleTo: participantIds,\n        participantDetails: participants,\n        unreadCounts: initialUnread,\n        createdAt: serverTimestamp(),\n        lastMessage: \"Chat created\",\n        lastMessageTime: new Date()\n      });\n      return {\n        id: docRef.id,\n        participants: participantIds,\n        participantDetails: participants\n      };\n    } catch (error) {\n      console.error(\"Error creating chat:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  // 4. SEND MESSAGE\n  const sendMessage = async (chatId, text, currentParticipants, imageUrl = null) => {\n    try {\n      await addDoc(collection(db, \"chats\", chatId, \"messages\"), {\n        text: text,\n        imageUrl: imageUrl,\n        senderId: loggedInUser.uid,\n        senderName: loggedInUser.playerName,\n        createdAt: serverTimestamp()\n      });\n      const chatRef = doc(db, \"chats\", chatId);\n      let summary = text;\n      if (imageUrl) {\n        summary = text ? `ðŸ“· ${text}` : \"ðŸ“· Sent an image\";\n      }\n      const visibleToUpdate = currentParticipants || [loggedInUser.uid];\n      const updatePayload = {\n        lastMessage: summary,\n        lastMessageTime: new Date(),\n        visibleTo: visibleToUpdate\n      };\n      const unreadUpdates = {};\n      if (currentParticipants) {\n        currentParticipants.forEach(uid => {\n          if (uid !== loggedInUser.uid) {\n            unreadUpdates[`unreadCounts.${uid}`] = increment(1);\n          }\n        });\n      }\n      await updateDoc(chatRef, {\n        ...updatePayload,\n        ...unreadUpdates\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error sending message:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  // 5. ADMIN / UTILS\n  const hideChat = async (chatId, currentVisibleTo, chatType) => {\n    if (chatType === 'roster') {\n      alert(\"Team Roster chats cannot be deleted.\");\n      return false;\n    }\n    try {\n      const newVisibleTo = currentVisibleTo.filter(uid => uid !== loggedInUser.uid);\n      if (newVisibleTo.length === 0) {\n        await deleteDoc(doc(db, \"chats\", chatId));\n      } else {\n        const chatRef = doc(db, \"chats\", chatId);\n        await updateDoc(chatRef, {\n          visibleTo: newVisibleTo\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Error hiding chat:\", error);\n      return false;\n    }\n  };\n  const renameChat = async (chatId, newName) => {\n    try {\n      const chatRef = doc(db, \"chats\", chatId);\n      await updateDoc(chatRef, {\n        name: newName\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error renaming chat:\", error);\n      return false;\n    }\n  };\n\n  // Need this for arrayUnion in createChat\n  const {\n    arrayUnion\n  } = require(\"firebase/firestore\");\n  const value = {\n    myChats,\n    createChat,\n    sendMessage,\n    hideChat,\n    renameChat,\n    markChatAsRead\n  };\n  return /*#__PURE__*/_jsxDEV(ChatContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 240,\n    columnNumber: 5\n  }, this);\n};\n_s2(ChatProvider, \"Zi8IvpC5T4q6G609hIr4YEPLgRE=\", false, function () {\n  return [useAuth];\n});\n_c = ChatProvider;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","collection","addDoc","setDoc","updateDoc","deleteDoc","doc","query","where","orderBy","onSnapshot","serverTimestamp","increment","db","useAuth","jsxDEV","_jsxDEV","ChatContext","useChat","_s","ChatProvider","children","_s2","loggedInUser","myChats","setMyChats","chatsRef","q","uid","unsubscribe","snapshot","chats","docs","map","id","data","error","console","markChatAsRead","chatId","chatRef","unreadCounts","merge","e","createChat","participantEmails","chatName","usersRef","participants","participantIds","push","name","playerName","email","photoURL","querySnapshot","then","mod","getDocs","empty","userDoc","userData","length","alert","existingChat","find","c","every","includes","visibleTo","arrayUnion","initialUnread","forEach","docRef","type","participantDetails","createdAt","lastMessage","lastMessageTime","Date","message","sendMessage","text","currentParticipants","imageUrl","senderId","senderName","summary","visibleToUpdate","updatePayload","unreadUpdates","hideChat","currentVisibleTo","chatType","newVisibleTo","filter","renameChat","newName","require","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/dbroxton/Documents/Projects/soccer-management-app/src/context/ChatContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect } from 'react';\nimport { \n  collection, addDoc, setDoc, updateDoc, deleteDoc, doc, \n  query, where, orderBy, onSnapshot, serverTimestamp, increment \n} from \"firebase/firestore\";\nimport { db } from \"../firebase\"; \nimport { useAuth } from './AuthContext';\n\nconst ChatContext = createContext();\n\nexport const useChat = () => {\n  return useContext(ChatContext);\n};\n\nexport const ChatProvider = ({ children }) => {\n  const { loggedInUser } = useAuth();\n  const [myChats, setMyChats] = useState([]);\n\n  // 1. GLOBAL LISTENER: Fetch chats for the logged-in user\n  useEffect(() => {\n    if (!loggedInUser) {\n      setMyChats([]);\n      return;\n    }\n\n    const chatsRef = collection(db, \"chats\");\n    const q = query(\n      chatsRef, \n      where(\"visibleTo\", \"array-contains\", loggedInUser.uid), \n      orderBy(\"lastMessageTime\", \"desc\")\n    );\n\n    const unsubscribe = onSnapshot(q, (snapshot) => {\n      const chats = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setMyChats(chats);\n    }, (error) => {\n      console.error(\"Error listening to chat list:\", error);\n    });\n\n    return () => unsubscribe();\n  }, [loggedInUser]);\n\n  // 2. MARK READ\n  const markChatAsRead = async (chatId) => {\n    if (!loggedInUser) return;\n    try {\n      const chatRef = doc(db, \"chats\", chatId);\n      await updateDoc(chatRef, {\n        [`unreadCounts.${loggedInUser.uid}`]: 0\n      });\n    } catch (error) {\n      // Fallback for older documents without the field\n      try {\n        const chatRef = doc(db, \"chats\", chatId);\n        await setDoc(chatRef, {\n          unreadCounts: { [loggedInUser.uid]: 0 }\n        }, { merge: true });\n      } catch (e) {\n        console.error(\"Error marking read:\", e);\n      }\n    }\n  };\n\n  // 3. CREATE CHAT\n  const createChat = async (participantEmails, chatName = \"\") => {\n    try {\n      const usersRef = collection(db, \"users\");\n      const participants = [];\n      const participantIds = [loggedInUser.uid];\n\n      // Add self\n      participants.push({\n        uid: loggedInUser.uid,\n        name: loggedInUser.playerName,\n        email: loggedInUser.email,\n        photoURL: loggedInUser.photoURL || \"\" \n      });\n\n      // Resolve other emails to Users\n      for (const email of participantEmails) {\n        if (email === loggedInUser.email) continue; \n        const q = query(usersRef, where(\"email\", \"==\", email));\n        const querySnapshot = await import(\"firebase/firestore\").then(mod => mod.getDocs(q));\n        \n        if (!querySnapshot.empty) {\n          const userDoc = querySnapshot.docs[0];\n          const userData = userDoc.data();\n          participantIds.push(userDoc.id);\n          participants.push({\n            uid: userDoc.id,\n            name: userData.playerName || \"Unknown\",\n            email: userData.email,\n            photoURL: userData.photoURL || \"\" \n          });\n        }\n      }\n\n      if (participantIds.length < 2) {\n        alert(\"Could not find any valid users to chat with.\");\n        return false;\n      }\n\n      // Check for existing 1:1 or exact group match\n      // (Note: We are doing a client-side check on the 'myChats' we already loaded)\n      const existingChat = myChats.find(c => {\n        if (c.participants.length !== participantIds.length) return false;\n        return participantIds.every(id => c.participants.includes(id));\n      });\n\n      if (existingChat) {\n        const chatRef = doc(db, \"chats\", existingChat.id);\n        if (!existingChat.visibleTo.includes(loggedInUser.uid)) {\n           await updateDoc(chatRef, {\n             visibleTo: arrayUnion(loggedInUser.uid)\n           });\n        }\n        return { \n          id: existingChat.id, \n          participants: existingChat.participants,\n          name: existingChat.name, \n          ...existingChat\n        };\n      }\n\n      // Create New\n      const initialUnread = {};\n      participantIds.forEach(uid => initialUnread[uid] = 0);\n\n      const docRef = await addDoc(collection(db, \"chats\"), {\n        type: participantIds.length > 2 ? 'group' : 'dm',\n        name: chatName || (participants.length === 2 ? participants[1].name : \"Group Chat\"),\n        participants: participantIds,\n        visibleTo: participantIds,\n        participantDetails: participants,\n        unreadCounts: initialUnread,\n        createdAt: serverTimestamp(),\n        lastMessage: \"Chat created\",\n        lastMessageTime: new Date() \n      });\n      \n      return { id: docRef.id, participants: participantIds, participantDetails: participants }; \n\n    } catch (error) {\n      console.error(\"Error creating chat:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  // 4. SEND MESSAGE\n  const sendMessage = async (chatId, text, currentParticipants, imageUrl = null) => {\n    try {\n      await addDoc(collection(db, \"chats\", chatId, \"messages\"), {\n        text: text,\n        imageUrl: imageUrl,\n        senderId: loggedInUser.uid,\n        senderName: loggedInUser.playerName,\n        createdAt: serverTimestamp()\n      });\n\n      const chatRef = doc(db, \"chats\", chatId);\n      let summary = text;\n      if (imageUrl) {\n        summary = text ? `ðŸ“· ${text}` : \"ðŸ“· Sent an image\";\n      }\n\n      const visibleToUpdate = currentParticipants || [loggedInUser.uid];\n      const updatePayload = {\n        lastMessage: summary,\n        lastMessageTime: new Date(),\n        visibleTo: visibleToUpdate\n      };\n\n      const unreadUpdates = {};\n      if (currentParticipants) {\n        currentParticipants.forEach(uid => {\n          if (uid !== loggedInUser.uid) {\n            unreadUpdates[`unreadCounts.${uid}`] = increment(1);\n          }\n        });\n      }\n\n      await updateDoc(chatRef, { ...updatePayload, ...unreadUpdates });\n      return true;\n    } catch (error) {\n      console.error(\"Error sending message:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  // 5. ADMIN / UTILS\n  const hideChat = async (chatId, currentVisibleTo, chatType) => {\n    if (chatType === 'roster') {\n      alert(\"Team Roster chats cannot be deleted.\");\n      return false;\n    }\n    try {\n      const newVisibleTo = currentVisibleTo.filter(uid => uid !== loggedInUser.uid);\n      if (newVisibleTo.length === 0) {\n        await deleteDoc(doc(db, \"chats\", chatId));\n      } else {\n        const chatRef = doc(db, \"chats\", chatId);\n        await updateDoc(chatRef, { visibleTo: newVisibleTo });\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Error hiding chat:\", error);\n      return false;\n    }\n  };\n\n  const renameChat = async (chatId, newName) => {\n    try {\n      const chatRef = doc(db, \"chats\", chatId);\n      await updateDoc(chatRef, { name: newName });\n      return true;\n    } catch (error) {\n      console.error(\"Error renaming chat:\", error);\n      return false;\n    }\n  };\n\n  // Need this for arrayUnion in createChat\n  const { arrayUnion } = require(\"firebase/firestore\"); \n\n  const value = {\n    myChats,\n    createChat,\n    sendMessage,\n    hideChat,\n    renameChat,\n    markChatAsRead\n  };\n\n  return (\n    <ChatContext.Provider value={value}>\n      {children}\n    </ChatContext.Provider>\n  );\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}