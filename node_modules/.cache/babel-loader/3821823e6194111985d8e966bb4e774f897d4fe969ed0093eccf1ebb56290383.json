{"ast":null,"code":"var _jsxFileName = \"/Users/dbroxton/Documents/Projects/soccer-management-app/src/context/AuthContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport { onAuthStateChanged, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, updateEmail, updateProfile as firebaseUpdateProfile, EmailAuthProvider, reauthenticateWithCredential, deleteUser } from \"firebase/auth\";\nimport { doc, getDoc, setDoc, updateDoc, collection, addDoc, getDocs, deleteDoc, query, where, arrayUnion, arrayRemove, orderBy, serverTimestamp, deleteField, onSnapshot, increment } from \"firebase/firestore\";\nimport { ref, uploadBytes, getDownloadURL, deleteObject } from \"firebase/storage\";\nimport { auth, db, storage } from \"../config/firebase\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AuthContext = /*#__PURE__*/createContext();\nexport const useAuth = () => {\n  _s();\n  return useContext(AuthContext);\n};\n_s(useAuth, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const AuthProvider = ({\n  children\n}) => {\n  _s2();\n  const [loggedInUser, setLoggedInUser] = useState(null);\n  const [soccerDetails, setSoccerDetails] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [needsReauth, setNeedsReauth] = useState(false);\n  useEffect(() => {\n    const unsubscribe = onAuthStateChanged(auth, async user => {\n      if (user) {\n        const userDocRef = doc(db, \"users\", user.uid);\n        const userDoc = await getDoc(userDocRef);\n        const soccerDocRef = doc(db, \"users\", user.uid, \"sportsDetails\", \"soccer\");\n        const soccerDoc = await getDoc(soccerDocRef);\n        if (userDoc.exists()) {\n          setLoggedInUser(userDoc.data());\n        } else {\n          setLoggedInUser(null);\n        }\n        if (soccerDoc.exists()) {\n          setSoccerDetails(soccerDoc.data());\n        } else {\n          setSoccerDetails(null);\n        }\n      } else {\n        setLoggedInUser(null);\n        setSoccerDetails(null);\n      }\n      setIsLoading(false);\n    });\n    return () => unsubscribe();\n  }, []);\n  const signIn = async (email, password) => {\n    setIsLoading(true);\n    try {\n      await signInWithEmailAndPassword(auth, email, password);\n    } catch (error) {\n      console.error(\"Error signing in:\", error);\n      alert(\"Error: \" + error.message);\n    }\n    setIsLoading(false);\n  };\n\n  // --- UPDATED SIGN UP ---\n  const signUp = async formData => {\n    if (formData.password.length < 6) {\n      alert(\"Password must be at least 6 characters long.\");\n      return;\n    }\n    let userCredential;\n    try {\n      userCredential = await createUserWithEmailAndPassword(auth, formData.email, formData.password);\n      const user = userCredential.user;\n\n      // Concatenate First + Last for display name compatibility\n      const displayName = `${formData.firstName} ${formData.lastName}`;\n      const userProfileData = {\n        uid: user.uid,\n        firstName: formData.firstName,\n        lastName: formData.lastName,\n        preferredName: formData.preferredName,\n        playerName: displayName,\n        // Kept for display/compatibility\n        email: formData.email,\n        phone: formData.phone,\n        notificationPreference: formData.notificationPreference,\n        // Emergency Contact Object\n        emergencyContact: {\n          firstName: formData.emergencyContactFirstName,\n          lastName: formData.emergencyContactLastName,\n          phone: formData.emergencyContactPhone,\n          relationship: formData.emergencyContactRelationship\n        },\n        role: 'player',\n        photoURL: \"\"\n      };\n      await setDoc(doc(db, \"users\", user.uid), userProfileData);\n      setLoggedInUser(userProfileData);\n    } catch (error) {\n      console.error(\"Error signing up:\", error);\n      alert(\"Error: \" + error.message);\n      if (userCredential && userCredential.user) {\n        try {\n          await deleteUser(userCredential.user);\n        } catch (cleanupError) {\n          console.error(\"Failed to cleanup user:\", cleanupError);\n        }\n      }\n    }\n  };\n  const signOutUser = async () => {\n    try {\n      await signOut(auth);\n      setLoggedInUser(null);\n      setSoccerDetails(null);\n    } catch (error) {\n      console.error(\"Error signing out:\", error);\n      alert(\"Error: \" + error.message);\n    }\n  };\n  const uploadProfileImage = async (file, uid) => {\n    if (!file) return null;\n    try {\n      const storageRef = ref(storage, `users/${uid}/profile.jpg`);\n      await uploadBytes(storageRef, file);\n      return await getDownloadURL(storageRef);\n    } catch (error) {\n      console.error(\"Error uploading profile image:\", error);\n      throw error;\n    }\n  };\n  const uploadImage = async (file, path) => {\n    if (!file) return null;\n    try {\n      const storageRef = ref(storage, `${path}/${Date.now()}_${file.name}`);\n      const snapshot = await uploadBytes(storageRef, file);\n      const downloadURL = await getDownloadURL(snapshot.ref);\n      return downloadURL;\n    } catch (error) {\n      console.error(\"Error uploading image:\", error);\n      throw error;\n    }\n  };\n  const deleteProfileImage = async uid => {\n    try {\n      const storageRef = ref(storage, `users/${uid}/profile.jpg`);\n      await deleteObject(storageRef);\n    } catch (error) {\n      console.warn(\"Error deleting image (might not exist):\", error);\n    }\n  };\n\n  // --- UPDATED UPDATE PROFILE ---\n  const updateProfile = async (profileData, newImageFile = null, removeImage = false) => {\n    if (!loggedInUser) return;\n    if (profileData.email !== loggedInUser.email) {\n      try {\n        await updateEmail(auth.currentUser, profileData.email);\n      } catch (error) {\n        if (error.code === 'auth/requires-recent-login') {\n          setNeedsReauth(true);\n        } else {\n          alert(\"Error: \" + error.message);\n        }\n        return;\n      }\n    }\n    try {\n      let photoURL = loggedInUser.photoURL;\n      if (removeImage) {\n        await deleteProfileImage(loggedInUser.uid);\n        photoURL = \"\";\n      } else if (newImageFile) {\n        photoURL = await uploadProfileImage(newImageFile, loggedInUser.uid);\n      }\n\n      // Concatenate for display\n      const displayName = `${profileData.firstName} ${profileData.lastName}`;\n      const dataToUpdate = {\n        firstName: profileData.firstName,\n        lastName: profileData.lastName,\n        preferredName: profileData.preferredName,\n        playerName: displayName,\n        phone: profileData.phone,\n        notificationPreference: profileData.notificationPreference,\n        emergencyContact: {\n          firstName: profileData.emergencyContactFirstName,\n          lastName: profileData.emergencyContactLastName,\n          phone: profileData.emergencyContactPhone,\n          relationship: profileData.emergencyContactRelationship\n        },\n        email: profileData.email,\n        photoURL: photoURL || \"\"\n      };\n      const userDocRef = doc(db, \"users\", loggedInUser.uid);\n      await updateDoc(userDocRef, dataToUpdate);\n      await firebaseUpdateProfile(auth.currentUser, {\n        displayName: displayName,\n        photoURL: photoURL\n      });\n      setLoggedInUser(prevUser => ({\n        ...prevUser,\n        ...dataToUpdate\n      }));\n\n      // Update denormalized data in chats\n      const chatsRef = collection(db, \"chats\");\n      const q = query(chatsRef, where(\"participants\", \"array-contains\", loggedInUser.uid));\n      const querySnapshot = await getDocs(q);\n      const batchPromises = querySnapshot.docs.map(async chatDoc => {\n        const chatData = chatDoc.data();\n        if (chatData.participantDetails) {\n          const updatedDetails = chatData.participantDetails.map(p => {\n            if (p.uid === loggedInUser.uid) {\n              return {\n                ...p,\n                name: displayName,\n                email: profileData.email,\n                photoURL: photoURL || \"\"\n              };\n            }\n            return p;\n          });\n          await updateDoc(chatDoc.ref, {\n            participantDetails: updatedDetails\n          });\n        }\n      });\n      await Promise.all(batchPromises);\n      alert(\"Profile successfully updated!\");\n      return true;\n    } catch (error) {\n      alert(\"Error saving profile: \" + error.message);\n      return false;\n    }\n  };\n  const reauthenticate = async (password, newEmail) => {\n    if (!auth.currentUser || !password) return;\n    try {\n      const credential = EmailAuthProvider.credential(auth.currentUser.email, password);\n      await reauthenticateWithCredential(auth.currentUser, credential);\n      await updateEmail(auth.currentUser, newEmail);\n      const userDocRef = doc(db, \"users\", loggedInUser.uid);\n      await updateDoc(userDocRef, {\n        email: newEmail\n      });\n      setLoggedInUser(prevUser => ({\n        ...prevUser,\n        email: newEmail\n      }));\n      alert(\"Email successfully updated!\");\n      setNeedsReauth(false);\n      return true;\n    } catch (error) {\n      alert(\"Error: Incorrect password or another error occurred. \" + error.message);\n      return false;\n    }\n  };\n  const updateSoccerDetails = async soccerData => {\n    if (!loggedInUser) return;\n    try {\n      const soccerDataToSave = {\n        ...soccerData,\n        currentRosters: soccerData.currentRosters.split(',').map(item => item.trim()),\n        rosterJerseysOwned: soccerData.rosterJerseysOwned.split(',').map(item => item.trim()),\n        playerNumber: Number(soccerData.playerNumber) || 0\n      };\n      const soccerDocRef = doc(db, \"users\", loggedInUser.uid, \"sportsDetails\", \"soccer\");\n      await setDoc(soccerDocRef, soccerDataToSave);\n      setSoccerDetails(soccerDataToSave);\n      alert(\"Soccer info saved!\");\n      return true;\n    } catch (error) {\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const isManager = () => {\n    return loggedInUser && loggedInUser.role === 'manager';\n  };\n  const createRoster = async (rosterName, season, maxCapacity, isDiscoverable = false, groupCreationData = null, addManagerAsPlayer = false) => {\n    if (!isManager()) {\n      alert(\"Only managers can create rosters.\");\n      return false;\n    }\n    try {\n      const initialPlayerIDs = [];\n      const initialPlayers = [];\n      if (addManagerAsPlayer) {\n        initialPlayerIDs.push(loggedInUser.uid);\n        initialPlayers.push({\n          uid: loggedInUser.uid,\n          playerName: loggedInUser.playerName,\n          email: loggedInUser.email,\n          photoURL: loggedInUser.photoURL || \"\"\n        });\n      }\n      const rosterRef = await addDoc(collection(db, \"rosters\"), {\n        name: rosterName,\n        season: season,\n        maxCapacity: Number(maxCapacity),\n        createdBy: loggedInUser.uid,\n        isDiscoverable: isDiscoverable,\n        createdAt: new Date(),\n        playerIDs: initialPlayerIDs,\n        players: initialPlayers\n      });\n      await addDoc(collection(db, \"chats\"), {\n        type: 'roster',\n        rosterId: rosterRef.id,\n        name: `${rosterName} (${season})`,\n        participants: [loggedInUser.uid],\n        visibleTo: [loggedInUser.uid],\n        participantDetails: [{\n          uid: loggedInUser.uid,\n          name: loggedInUser.playerName,\n          email: loggedInUser.email,\n          photoURL: loggedInUser.photoURL || \"\"\n        }],\n        unreadCounts: {\n          [loggedInUser.uid]: 0\n        },\n        createdAt: serverTimestamp(),\n        lastMessage: \"Team chat created\",\n        lastMessageTime: serverTimestamp()\n      });\n      if (groupCreationData && groupCreationData.createGroup) {\n        await addDoc(collection(db, \"groups\"), {\n          name: groupCreationData.groupName || rosterName,\n          description: `Official group for ${rosterName} (${season})`,\n          isPublic: false,\n          createdBy: loggedInUser.uid,\n          associatedRosterId: rosterRef.id,\n          createdAt: serverTimestamp(),\n          members: [loggedInUser.uid],\n          memberDetails: [{\n            uid: loggedInUser.uid,\n            name: loggedInUser.playerName,\n            email: loggedInUser.email,\n            photoURL: loggedInUser.photoURL || \"\",\n            role: 'owner'\n          }]\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Error creating roster:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const fetchRosters = async () => {\n    try {\n      const querySnapshot = await getDocs(collection(db, \"rosters\"));\n      return querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error(\"Error fetching rosters:\", error);\n      return [];\n    }\n  };\n  const deleteRoster = async rosterId => {\n    if (!isManager()) return false;\n    try {\n      await deleteDoc(doc(db, \"rosters\", rosterId));\n      const chatsRef = collection(db, \"chats\");\n      const q = query(chatsRef, where(\"rosterId\", \"==\", rosterId));\n      const querySnapshot = await getDocs(q);\n      const batchPromises = querySnapshot.docs.map(async chatDoc => {\n        const systemMessage = \"This team has been disbanded by the manager. This chat is now a regular group.\";\n        await addDoc(collection(db, \"chats\", chatDoc.id, \"messages\"), {\n          text: systemMessage,\n          type: 'system',\n          createdAt: serverTimestamp()\n        });\n        await updateDoc(chatDoc.ref, {\n          type: 'group',\n          rosterId: deleteField(),\n          lastMessage: systemMessage,\n          lastMessageTime: serverTimestamp()\n        });\n      });\n      await Promise.all(batchPromises);\n      return true;\n    } catch (error) {\n      console.error(\"Error deleting roster:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const addPlayerToRoster = async (rosterId, playerEmail) => {\n    if (!isManager()) return false;\n    try {\n      const usersRef = collection(db, \"users\");\n      const q = query(usersRef, where(\"email\", \"==\", playerEmail));\n      const querySnapshot = await getDocs(q);\n      if (querySnapshot.empty) {\n        alert(\"No player found with that email address.\");\n        return false;\n      }\n      const playerDoc = querySnapshot.docs[0];\n      const playerData = playerDoc.data();\n      const playerSummary = {\n        uid: playerDoc.id,\n        playerName: playerData.playerName || \"Unknown\",\n        email: playerData.email,\n        photoURL: playerData.photoURL || \"\"\n      };\n      const rosterRef = doc(db, \"rosters\", rosterId);\n      await updateDoc(rosterRef, {\n        playerIDs: arrayUnion(playerDoc.id),\n        players: arrayUnion(playerSummary)\n      });\n      const chatsRef = collection(db, \"chats\");\n      const chatQ = query(chatsRef, where(\"rosterId\", \"==\", rosterId));\n      const chatSnapshot = await getDocs(chatQ);\n      if (!chatSnapshot.empty) {\n        const chatDoc = chatSnapshot.docs[0];\n        await setDoc(chatDoc.ref, {\n          participants: arrayUnion(playerDoc.id),\n          visibleTo: arrayUnion(playerDoc.id),\n          participantDetails: arrayUnion(playerSummary),\n          unreadCounts: {\n            [playerDoc.id]: 0\n          }\n        }, {\n          merge: true\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Error adding player:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const removePlayerFromRoster = async (rosterId, playerSummary) => {\n    if (!isManager()) return false;\n    try {\n      const rosterRef = doc(db, \"rosters\", rosterId);\n      await updateDoc(rosterRef, {\n        playerIDs: arrayRemove(playerSummary.uid),\n        players: arrayRemove(playerSummary)\n      });\n      const chatsRef = collection(db, \"chats\");\n      const chatQ = query(chatsRef, where(\"rosterId\", \"==\", rosterId));\n      const chatSnapshot = await getDocs(chatQ);\n      if (!chatSnapshot.empty) {\n        const chatDoc = chatSnapshot.docs[0];\n        await updateDoc(chatDoc.ref, {\n          participants: arrayRemove(playerSummary.uid),\n          visibleTo: arrayRemove(playerSummary.uid),\n          participantDetails: arrayRemove(playerSummary)\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Error removing player:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const fetchUserRosters = async uid => {\n    try {\n      const rostersRef = collection(db, \"rosters\");\n      const q = query(rostersRef, where(\"playerIDs\", \"array-contains\", uid));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error(\"Error fetching user rosters:\", error);\n      return [];\n    }\n  };\n  const createEvent = async (rosterId, eventData) => {\n    try {\n      await addDoc(collection(db, \"rosters\", rosterId, \"events\"), {\n        ...eventData,\n        createdAt: new Date()\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating event:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const fetchEvents = async rosterId => {\n    try {\n      const eventsRef = collection(db, \"rosters\", rosterId, \"events\");\n      const q = query(eventsRef, orderBy(\"dateTime\", \"asc\"));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error(\"Error fetching events:\", error);\n      return [];\n    }\n  };\n  const deleteEvent = async (rosterId, eventId) => {\n    if (!isManager()) return false;\n    try {\n      await deleteDoc(doc(db, \"rosters\", rosterId, \"events\", eventId));\n      return true;\n    } catch (error) {\n      console.error(\"Error deleting event:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const fetchAllUserEvents = async uid => {\n    try {\n      const rosters = await fetchUserRosters(uid);\n      let allEvents = [];\n      for (const roster of rosters) {\n        const eventsRef = collection(db, \"rosters\", roster.id, \"events\");\n        const q = query(eventsRef);\n        const querySnapshot = await getDocs(q);\n        const rosterEvents = querySnapshot.docs.map(doc => ({\n          id: doc.id,\n          rosterName: roster.name,\n          ...doc.data()\n        }));\n        allEvents = [...allEvents, ...rosterEvents];\n      }\n      allEvents.sort((a, b) => new Date(a.dateTime) - new Date(b.dateTime));\n      return allEvents;\n    } catch (error) {\n      console.error(\"Error fetching all events:\", error);\n      return [];\n    }\n  };\n  const createGroup = async groupData => {\n    try {\n      await addDoc(collection(db, \"groups\"), {\n        ...groupData,\n        createdBy: loggedInUser.uid,\n        createdAt: serverTimestamp(),\n        members: [loggedInUser.uid],\n        memberDetails: [{\n          uid: loggedInUser.uid,\n          name: loggedInUser.playerName,\n          email: loggedInUser.email,\n          photoURL: loggedInUser.photoURL || \"\",\n          role: 'owner'\n        }]\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating group:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const fetchUserGroups = async uid => {\n    try {\n      const groupsRef = collection(db, \"groups\");\n      const q = query(groupsRef, where(\"members\", \"array-contains\", uid));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error(\"Error fetching groups:\", error);\n      return [];\n    }\n  };\n  const createGroupPost = async (groupId, text, imageUrl = null) => {\n    try {\n      await addDoc(collection(db, \"groups\", groupId, \"posts\"), {\n        text: text,\n        imageUrl: imageUrl,\n        authorId: loggedInUser.uid,\n        authorName: loggedInUser.playerName,\n        authorPhoto: loggedInUser.photoURL || \"\",\n        createdAt: serverTimestamp(),\n        replies: []\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating post:\", error);\n      return false;\n    }\n  };\n  const addGroupMembers = async (groupId, emails) => {\n    try {\n      const groupRef = doc(db, \"groups\", groupId);\n      const groupSnap = await getDoc(groupRef);\n      if (!groupSnap.exists()) return false;\n      const groupData = groupSnap.data();\n      const myMemberDetails = groupData.memberDetails.find(m => m.uid === loggedInUser.uid);\n      if (!myMemberDetails || myMemberDetails.role !== 'owner' && myMemberDetails.role !== 'admin') {\n        alert(\"Only Owners and Admins can add members.\");\n        return false;\n      }\n      const usersRef = collection(db, \"users\");\n      const newMembers = [];\n      const newMemberIds = [];\n      for (const email of emails) {\n        const q = query(usersRef, where(\"email\", \"==\", email));\n        const snapshot = await getDocs(q);\n        if (!snapshot.empty) {\n          const userDoc = snapshot.docs[0];\n          const userData = userDoc.data();\n          if (!groupData.members.includes(userDoc.id)) {\n            newMemberIds.push(userDoc.id);\n            newMembers.push({\n              uid: userDoc.id,\n              name: userData.playerName || \"Unknown\",\n              email: userData.email,\n              photoURL: userData.photoURL || \"\",\n              role: 'member'\n            });\n          }\n        }\n      }\n      if (newMemberIds.length === 0) {\n        return true;\n      }\n      await updateDoc(groupRef, {\n        members: arrayUnion(...newMemberIds),\n        memberDetails: arrayUnion(...newMembers)\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error adding group members:\", error);\n      alert(\"Error adding members: \" + error.message);\n      return false;\n    }\n  };\n  const updateGroupMemberRole = async (groupId, memberUid, newRole, currentMemberDetails) => {\n    try {\n      const groupRef = doc(db, \"groups\", groupId);\n      const updatedMemberDetails = currentMemberDetails.map(member => {\n        if (member.uid === memberUid) {\n          return {\n            ...member,\n            role: newRole\n          };\n        }\n        return member;\n      });\n      await updateDoc(groupRef, {\n        memberDetails: updatedMemberDetails\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error updating role:\", error);\n      alert(\"Error updating role: \" + error.message);\n      return false;\n    }\n  };\n  const transferGroupOwnership = async (groupId, newOwnerUid, currentMemberDetails) => {\n    try {\n      const groupRef = doc(db, \"groups\", groupId);\n      const updatedMemberDetails = currentMemberDetails.map(member => {\n        if (member.uid === loggedInUser.uid) {\n          return {\n            ...member,\n            role: 'admin'\n          };\n        }\n        if (member.uid === newOwnerUid) {\n          return {\n            ...member,\n            role: 'owner'\n          };\n        }\n        return member;\n      });\n      await updateDoc(groupRef, {\n        memberDetails: updatedMemberDetails\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error transferring ownership:\", error);\n      alert(\"Error transferring ownership: \" + error.message);\n      return false;\n    }\n  };\n  const removeGroupMember = async (groupId, memberUid, currentMemberDetails, currentMembers) => {\n    try {\n      const groupRef = doc(db, \"groups\", groupId);\n      const updatedMemberDetails = currentMemberDetails.filter(m => m.uid !== memberUid);\n      const updatedMembers = currentMembers.filter(uid => uid !== memberUid);\n      await updateDoc(groupRef, {\n        memberDetails: updatedMemberDetails,\n        members: updatedMembers\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error removing member:\", error);\n      alert(\"Error removing member: \" + error.message);\n      return false;\n    }\n  };\n  const subscribeToIncomingRequests = callback => {\n    if (!isManager()) return () => {};\n    const requestsRef = collection(db, \"rosterRequests\");\n    const q = query(requestsRef, where(\"managerId\", \"==\", loggedInUser.uid));\n    return onSnapshot(q, snapshot => {\n      const requests = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      callback(requests);\n    });\n  };\n  const subscribeToUserRequests = callback => {\n    if (!loggedInUser) return () => {};\n    const requestsRef = collection(db, \"rosterRequests\");\n    const q = query(requestsRef, where(\"userId\", \"==\", loggedInUser.uid));\n    return onSnapshot(q, snapshot => {\n      const requests = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      callback(requests);\n    });\n  };\n  const subscribeToDiscoverableRosters = callback => {\n    const rostersRef = collection(db, \"rosters\");\n    const q = query(rostersRef, where(\"isDiscoverable\", \"==\", true));\n    return onSnapshot(q, snapshot => {\n      const rosters = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      callback(rosters);\n    });\n  };\n  const submitJoinRequest = async (rosterId, rosterName, managerId) => {\n    try {\n      const requestsRef = collection(db, \"rosterRequests\");\n      const q = query(requestsRef, where(\"rosterId\", \"==\", rosterId), where(\"userId\", \"==\", loggedInUser.uid));\n      const existing = await getDocs(q);\n      if (!existing.empty) {\n        alert(\"You have already sent a request for this team.\");\n        return false;\n      }\n      await addDoc(requestsRef, {\n        rosterId,\n        rosterName,\n        managerId,\n        userId: loggedInUser.uid,\n        userName: loggedInUser.playerName,\n        userEmail: loggedInUser.email,\n        status: 'pending',\n        createdAt: serverTimestamp()\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error submitting request:\", error);\n      alert(\"Failed to submit request: \" + error.message);\n      return false;\n    }\n  };\n  const fetchIncomingRequests = async () => {\n    if (!isManager()) return [];\n    try {\n      const requestsRef = collection(db, \"rosterRequests\");\n      const q = query(requestsRef, where(\"managerId\", \"==\", loggedInUser.uid));\n      const snapshot = await getDocs(q);\n      return snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error(\"Error fetching incoming requests:\", error);\n      return [];\n    }\n  };\n  const fetchUserRequests = async () => {\n    try {\n      const requestsRef = collection(db, \"rosterRequests\");\n      const q = query(requestsRef, where(\"userId\", \"==\", loggedInUser.uid));\n      const snapshot = await getDocs(q);\n      return snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error(\"Error fetching user requests:\", error);\n      return [];\n    }\n  };\n  const fetchDiscoverableRosters = async () => {\n    try {\n      const rostersRef = collection(db, \"rosters\");\n      const q = query(rostersRef, where(\"isDiscoverable\", \"==\", true));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error(\"Error fetching discoverable rosters:\", error);\n      return [];\n    }\n  };\n  const fetchPlayerDetails = async uid => {\n    try {\n      const userDocRef = doc(db, \"users\", uid);\n      const userSnap = await getDoc(userDocRef);\n      if (!userSnap.exists()) return null;\n      const soccerDocRef = doc(db, \"users\", uid, \"sportsDetails\", \"soccer\");\n      const soccerSnap = await getDoc(soccerDocRef);\n      return {\n        ...userSnap.data(),\n        soccerDetails: soccerSnap.exists() ? soccerSnap.data() : null\n      };\n    } catch (error) {\n      console.error(\"Error fetching player details:\", error);\n      return null;\n    }\n  };\n  const respondToRequest = async (request, action, targetGroupId = null) => {\n    if (!isManager()) return false;\n    try {\n      if (action === 'approve') {\n        const userDocRef = doc(db, \"users\", request.userId);\n        const userSnap = await getDoc(userDocRef);\n        if (!userSnap.exists()) {\n          alert(\"User no longer exists.\");\n          await deleteDoc(doc(db, \"rosterRequests\", request.id));\n          return false;\n        }\n        const userData = userSnap.data();\n        const playerSummary = {\n          uid: request.userId,\n          playerName: userData.playerName || \"Unknown\",\n          email: userData.email,\n          photoURL: userData.photoURL || \"\"\n        };\n\n        // 1. Add to Roster\n        const rosterRef = doc(db, \"rosters\", request.rosterId);\n        await updateDoc(rosterRef, {\n          playerIDs: arrayUnion(request.userId),\n          players: arrayUnion(playerSummary)\n        });\n\n        // 2. Add to Chat\n        const chatsRef = collection(db, \"chats\");\n        const chatQ = query(chatsRef, where(\"rosterId\", \"==\", request.rosterId));\n        const chatSnapshot = await getDocs(chatQ);\n        if (!chatSnapshot.empty) {\n          const chatDoc = chatSnapshot.docs[0];\n          await setDoc(chatDoc.ref, {\n            participants: arrayUnion(request.userId),\n            visibleTo: arrayUnion(request.userId),\n            participantDetails: arrayUnion(playerSummary),\n            unreadCounts: {\n              [request.userId]: 0\n            }\n          }, {\n            merge: true\n          });\n        }\n\n        // 3. Add to Targeted Group (if selected)\n        if (targetGroupId) {\n          const groupRef = doc(db, \"groups\", targetGroupId);\n          const groupSnap = await getDoc(groupRef);\n          if (groupSnap.exists()) {\n            await updateDoc(groupRef, {\n              members: arrayUnion(request.userId),\n              memberDetails: arrayUnion({\n                uid: request.userId,\n                name: userData.playerName || \"Unknown\",\n                email: userData.email,\n                photoURL: userData.photoURL || \"\",\n                role: 'member'\n              })\n            });\n          }\n        }\n      }\n      await deleteDoc(doc(db, \"rosterRequests\", request.id));\n      return true;\n    } catch (error) {\n      console.error(\"Error responding to request:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  // --- NEW FEEDBACK FUNCTIONS ---\n\n  const createFeedback = async data => {\n    try {\n      await addDoc(collection(db, \"feedback\"), {\n        ...data,\n        authorId: loggedInUser.uid,\n        authorName: loggedInUser.playerName,\n        status: 'Proposed',\n        // Default status\n        developerNotes: '',\n        votes: 0,\n        voters: [],\n        // Array to track who voted\n        createdAt: serverTimestamp()\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating feedback:\", error);\n      alert(\"Error submitting feedback: \" + error.message);\n      return false;\n    }\n  };\n  const subscribeToFeedback = callback => {\n    // Order by votes descending (highest votes first)\n    const feedbackRef = collection(db, \"feedback\");\n    const q = query(feedbackRef, orderBy(\"votes\", \"desc\"));\n    return onSnapshot(q, snapshot => {\n      const items = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      callback(items);\n    });\n  };\n  const voteForFeedback = async feedbackId => {\n    if (!loggedInUser) return;\n    try {\n      const feedbackRef = doc(db, \"feedback\", feedbackId);\n      const feedbackSnap = await getDoc(feedbackRef);\n      if (feedbackSnap.exists()) {\n        const data = feedbackSnap.data();\n        // Check if user already voted\n        if (data.voters && data.voters.includes(loggedInUser.uid)) {\n          alert(\"You have already voted for this item.\");\n          return false;\n        }\n        await updateDoc(feedbackRef, {\n          votes: increment(1),\n          voters: arrayUnion(loggedInUser.uid)\n        });\n        return true;\n      }\n    } catch (error) {\n      console.error(\"Error voting:\", error);\n      return false;\n    }\n  };\n\n  // --- VALUE OBJECT ---\n  const value = {\n    loggedInUser,\n    soccerDetails,\n    isLoading,\n    needsReauth,\n    setNeedsReauth,\n    signIn,\n    signUp,\n    signOutUser,\n    updateProfile,\n    reauthenticate,\n    updateSoccerDetails,\n    isManager,\n    createRoster,\n    fetchRosters,\n    deleteRoster,\n    addPlayerToRoster,\n    removePlayerFromRoster,\n    fetchUserRosters,\n    createEvent,\n    fetchEvents,\n    deleteEvent,\n    fetchAllUserEvents,\n    uploadImage,\n    createGroup,\n    fetchUserGroups,\n    createGroupPost,\n    addGroupMembers,\n    updateGroupMemberRole,\n    transferGroupOwnership,\n    removeGroupMember,\n    fetchDiscoverableRosters,\n    submitJoinRequest,\n    fetchIncomingRequests,\n    fetchUserRequests,\n    respondToRequest,\n    subscribeToIncomingRequests,\n    subscribeToUserRequests,\n    subscribeToDiscoverableRosters,\n    fetchPlayerDetails,\n    createFeedback,\n    subscribeToFeedback,\n    voteForFeedback\n  };\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1052,\n    columnNumber: 5\n  }, this);\n};\n_s2(AuthProvider, \"5MPytths2y1fFmqpbAcpPs27WVo=\");\n_c = AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","onAuthStateChanged","signInWithEmailAndPassword","createUserWithEmailAndPassword","signOut","updateEmail","updateProfile","firebaseUpdateProfile","EmailAuthProvider","reauthenticateWithCredential","deleteUser","doc","getDoc","setDoc","updateDoc","collection","addDoc","getDocs","deleteDoc","query","where","arrayUnion","arrayRemove","orderBy","serverTimestamp","deleteField","onSnapshot","increment","ref","uploadBytes","getDownloadURL","deleteObject","auth","db","storage","jsxDEV","_jsxDEV","AuthContext","useAuth","_s","AuthProvider","children","_s2","loggedInUser","setLoggedInUser","soccerDetails","setSoccerDetails","isLoading","setIsLoading","needsReauth","setNeedsReauth","unsubscribe","user","userDocRef","uid","userDoc","soccerDocRef","soccerDoc","exists","data","signIn","email","password","error","console","alert","message","signUp","formData","length","userCredential","displayName","firstName","lastName","userProfileData","preferredName","playerName","phone","notificationPreference","emergencyContact","emergencyContactFirstName","emergencyContactLastName","emergencyContactPhone","relationship","emergencyContactRelationship","role","photoURL","cleanupError","signOutUser","uploadProfileImage","file","storageRef","uploadImage","path","Date","now","name","snapshot","downloadURL","deleteProfileImage","warn","profileData","newImageFile","removeImage","currentUser","code","dataToUpdate","prevUser","chatsRef","q","querySnapshot","batchPromises","docs","map","chatDoc","chatData","participantDetails","updatedDetails","p","Promise","all","reauthenticate","newEmail","credential","updateSoccerDetails","soccerData","soccerDataToSave","currentRosters","split","item","trim","rosterJerseysOwned","playerNumber","Number","isManager","createRoster","rosterName","season","maxCapacity","isDiscoverable","groupCreationData","addManagerAsPlayer","initialPlayerIDs","initialPlayers","push","rosterRef","createdBy","createdAt","playerIDs","players","type","rosterId","id","participants","visibleTo","unreadCounts","lastMessage","lastMessageTime","createGroup","groupName","description","isPublic","associatedRosterId","members","memberDetails","fetchRosters","deleteRoster","systemMessage","text","addPlayerToRoster","playerEmail","usersRef","empty","playerDoc","playerData","playerSummary","chatQ","chatSnapshot","merge","removePlayerFromRoster","fetchUserRosters","rostersRef","createEvent","eventData","fetchEvents","eventsRef","deleteEvent","eventId","fetchAllUserEvents","rosters","allEvents","roster","rosterEvents","sort","a","b","dateTime","groupData","fetchUserGroups","groupsRef","createGroupPost","groupId","imageUrl","authorId","authorName","authorPhoto","replies","addGroupMembers","emails","groupRef","groupSnap","myMemberDetails","find","m","newMembers","newMemberIds","userData","includes","updateGroupMemberRole","memberUid","newRole","currentMemberDetails","updatedMemberDetails","member","transferGroupOwnership","newOwnerUid","removeGroupMember","currentMembers","filter","updatedMembers","subscribeToIncomingRequests","callback","requestsRef","requests","subscribeToUserRequests","subscribeToDiscoverableRosters","submitJoinRequest","managerId","existing","userId","userName","userEmail","status","fetchIncomingRequests","fetchUserRequests","fetchDiscoverableRosters","fetchPlayerDetails","userSnap","soccerSnap","respondToRequest","request","action","targetGroupId","createFeedback","developerNotes","votes","voters","subscribeToFeedback","feedbackRef","items","voteForFeedback","feedbackId","feedbackSnap","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/dbroxton/Documents/Projects/soccer-management-app/src/context/AuthContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect } from 'react';\nimport {\n  onAuthStateChanged,\n  signInWithEmailAndPassword,\n  createUserWithEmailAndPassword,\n  signOut,\n  updateEmail,\n  updateProfile as firebaseUpdateProfile,\n  EmailAuthProvider,\n  reauthenticateWithCredential,\n  deleteUser\n} from \"firebase/auth\";\nimport { \n  doc, getDoc, setDoc, updateDoc, collection, addDoc, getDocs, deleteDoc, \n  query, where, arrayUnion, arrayRemove, orderBy, serverTimestamp, \n  deleteField, onSnapshot, increment \n} from \"firebase/firestore\";\nimport { ref, uploadBytes, getDownloadURL, deleteObject } from \"firebase/storage\";\nimport { auth, db, storage } from \"../config/firebase\"; \n\nconst AuthContext = createContext();\n\nexport const useAuth = () => {\n  return useContext(AuthContext);\n};\n\nexport const AuthProvider = ({ children }) => {\n  const [loggedInUser, setLoggedInUser] = useState(null);\n  const [soccerDetails, setSoccerDetails] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [needsReauth, setNeedsReauth] = useState(false);\n\n  useEffect(() => {\n    const unsubscribe = onAuthStateChanged(auth, async (user) => {\n      if (user) {\n        const userDocRef = doc(db, \"users\", user.uid);\n        const userDoc = await getDoc(userDocRef);\n        const soccerDocRef = doc(db, \"users\", user.uid, \"sportsDetails\", \"soccer\");\n        const soccerDoc = await getDoc(soccerDocRef);\n\n        if (userDoc.exists()) {\n          setLoggedInUser(userDoc.data());\n        } else {\n          setLoggedInUser(null);\n        }\n\n        if (soccerDoc.exists()) {\n          setSoccerDetails(soccerDoc.data());\n        } else {\n          setSoccerDetails(null);\n        }\n      } else {\n        setLoggedInUser(null);\n        setSoccerDetails(null);\n      }\n      setIsLoading(false);\n    });\n\n    return () => unsubscribe();\n  }, []); \n\n  const signIn = async (email, password) => {\n    setIsLoading(true);\n    try {\n      await signInWithEmailAndPassword(auth, email, password);\n    } catch (error) {\n      console.error(\"Error signing in:\", error);\n      alert(\"Error: \" + error.message);\n    }\n    setIsLoading(false);\n  };\n\n  // --- UPDATED SIGN UP ---\n  const signUp = async (formData) => {\n    if (formData.password.length < 6) {\n      alert(\"Password must be at least 6 characters long.\");\n      return;\n    }\n    \n    let userCredential;\n    try {\n      userCredential = await createUserWithEmailAndPassword(auth, formData.email, formData.password);\n      const user = userCredential.user;\n      \n      // Concatenate First + Last for display name compatibility\n      const displayName = `${formData.firstName} ${formData.lastName}`;\n      \n      const userProfileData = {\n        uid: user.uid,\n        firstName: formData.firstName,\n        lastName: formData.lastName,\n        preferredName: formData.preferredName,\n        playerName: displayName, // Kept for display/compatibility\n        email: formData.email,\n        phone: formData.phone,\n        notificationPreference: formData.notificationPreference,\n        // Emergency Contact Object\n        emergencyContact: {\n            firstName: formData.emergencyContactFirstName,\n            lastName: formData.emergencyContactLastName,\n            phone: formData.emergencyContactPhone,\n            relationship: formData.emergencyContactRelationship\n        },\n        role: 'player', \n        photoURL: \"\"\n      };\n      \n      await setDoc(doc(db, \"users\", user.uid), userProfileData);\n      setLoggedInUser(userProfileData);\n\n    } catch (error) {\n      console.error(\"Error signing up:\", error);\n      alert(\"Error: \" + error.message);\n\n      if (userCredential && userCredential.user) {\n        try {\n          await deleteUser(userCredential.user);\n        } catch (cleanupError) {\n          console.error(\"Failed to cleanup user:\", cleanupError);\n        }\n      }\n    }\n  };\n\n  const signOutUser = async () => {\n    try {\n      await signOut(auth);\n      setLoggedInUser(null);\n      setSoccerDetails(null);\n    } catch (error) {\n      console.error(\"Error signing out:\", error);\n      alert(\"Error: \" + error.message);\n    }\n  };\n\n  const uploadProfileImage = async (file, uid) => {\n    if (!file) return null;\n    try {\n      const storageRef = ref(storage, `users/${uid}/profile.jpg`);\n      await uploadBytes(storageRef, file);\n      return await getDownloadURL(storageRef);\n    } catch (error) {\n      console.error(\"Error uploading profile image:\", error);\n      throw error;\n    }\n  };\n\n  const uploadImage = async (file, path) => {\n    if (!file) return null;\n    try {\n      const storageRef = ref(storage, `${path}/${Date.now()}_${file.name}`);\n      const snapshot = await uploadBytes(storageRef, file);\n      const downloadURL = await getDownloadURL(snapshot.ref);\n      return downloadURL;\n    } catch (error) {\n      console.error(\"Error uploading image:\", error);\n      throw error;\n    }\n  };\n\n  const deleteProfileImage = async (uid) => {\n    try {\n      const storageRef = ref(storage, `users/${uid}/profile.jpg`);\n      await deleteObject(storageRef);\n    } catch (error) {\n      console.warn(\"Error deleting image (might not exist):\", error);\n    }\n  };\n\n  // --- UPDATED UPDATE PROFILE ---\n  const updateProfile = async (profileData, newImageFile = null, removeImage = false) => {\n    if (!loggedInUser) return;\n\n    if (profileData.email !== loggedInUser.email) {\n      try {\n        await updateEmail(auth.currentUser, profileData.email);\n      } catch (error) {\n        if (error.code === 'auth/requires-recent-login') {\n          setNeedsReauth(true); \n        } else {\n          alert(\"Error: \" + error.message);\n        }\n        return;\n      }\n    }\n\n    try {\n      let photoURL = loggedInUser.photoURL;\n\n      if (removeImage) {\n        await deleteProfileImage(loggedInUser.uid);\n        photoURL = \"\";\n      } else if (newImageFile) {\n        photoURL = await uploadProfileImage(newImageFile, loggedInUser.uid);\n      }\n\n      // Concatenate for display\n      const displayName = `${profileData.firstName} ${profileData.lastName}`;\n\n      const dataToUpdate = {\n        firstName: profileData.firstName,\n        lastName: profileData.lastName,\n        preferredName: profileData.preferredName,\n        playerName: displayName,\n        phone: profileData.phone,\n        notificationPreference: profileData.notificationPreference,\n        emergencyContact: {\n            firstName: profileData.emergencyContactFirstName,\n            lastName: profileData.emergencyContactLastName,\n            phone: profileData.emergencyContactPhone,\n            relationship: profileData.emergencyContactRelationship\n        },\n        email: profileData.email,\n        photoURL: photoURL || \"\"\n      };\n      \n      const userDocRef = doc(db, \"users\", loggedInUser.uid);\n      await updateDoc(userDocRef, dataToUpdate);\n      \n      await firebaseUpdateProfile(auth.currentUser, {\n        displayName: displayName,\n        photoURL: photoURL\n      });\n      \n      setLoggedInUser(prevUser => ({\n        ...prevUser,\n        ...dataToUpdate\n      }));\n\n      // Update denormalized data in chats\n      const chatsRef = collection(db, \"chats\");\n      const q = query(chatsRef, where(\"participants\", \"array-contains\", loggedInUser.uid));\n      const querySnapshot = await getDocs(q);\n\n      const batchPromises = querySnapshot.docs.map(async (chatDoc) => {\n        const chatData = chatDoc.data();\n        if (chatData.participantDetails) {\n          const updatedDetails = chatData.participantDetails.map(p => {\n            if (p.uid === loggedInUser.uid) {\n              return { \n                ...p, \n                name: displayName, \n                email: profileData.email,\n                photoURL: photoURL || \"\" \n              };\n            }\n            return p;\n          });\n          await updateDoc(chatDoc.ref, { participantDetails: updatedDetails });\n        }\n      });\n      \n      await Promise.all(batchPromises);\n      \n      alert(\"Profile successfully updated!\");\n      return true; \n    } catch (error) {\n      alert(\"Error saving profile: \" + error.message);\n      return false;\n    }\n  };\n\n  const reauthenticate = async (password, newEmail) => {\n    if (!auth.currentUser || !password) return;\n    try {\n      const credential = EmailAuthProvider.credential(auth.currentUser.email, password);\n      await reauthenticateWithCredential(auth.currentUser, credential);\n      await updateEmail(auth.currentUser, newEmail);\n      const userDocRef = doc(db, \"users\", loggedInUser.uid);\n      await updateDoc(userDocRef, { email: newEmail });\n\n      setLoggedInUser(prevUser => ({\n        ...prevUser,\n        email: newEmail\n      }));\n\n      alert(\"Email successfully updated!\");\n      setNeedsReauth(false); \n      return true; \n    } catch (error) {\n      alert(\"Error: Incorrect password or another error occurred. \" + error.message);\n      return false;\n    }\n  };\n\n  const updateSoccerDetails = async (soccerData) => {\n    if (!loggedInUser) return;\n    try {\n      const soccerDataToSave = {\n        ...soccerData,\n        currentRosters: soccerData.currentRosters.split(',').map(item => item.trim()),\n        rosterJerseysOwned: soccerData.rosterJerseysOwned.split(',').map(item => item.trim()),\n        playerNumber: Number(soccerData.playerNumber) || 0,\n      };\n      \n      const soccerDocRef = doc(db, \"users\", loggedInUser.uid, \"sportsDetails\", \"soccer\");\n      await setDoc(soccerDocRef, soccerDataToSave);\n      \n      setSoccerDetails(soccerDataToSave); \n      alert(\"Soccer info saved!\");\n      return true; \n\n    } catch (error) {\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const isManager = () => {\n    return loggedInUser && loggedInUser.role === 'manager';\n  };\n\n  const createRoster = async (rosterName, season, maxCapacity, isDiscoverable = false, groupCreationData = null, addManagerAsPlayer = false) => {\n    if (!isManager()) {\n      alert(\"Only managers can create rosters.\");\n      return false;\n    }\n    try {\n      const initialPlayerIDs = [];\n      const initialPlayers = [];\n\n      if (addManagerAsPlayer) {\n          initialPlayerIDs.push(loggedInUser.uid);\n          initialPlayers.push({\n              uid: loggedInUser.uid,\n              playerName: loggedInUser.playerName,\n              email: loggedInUser.email,\n              photoURL: loggedInUser.photoURL || \"\"\n          });\n      }\n\n      const rosterRef = await addDoc(collection(db, \"rosters\"), {\n        name: rosterName,\n        season: season,\n        maxCapacity: Number(maxCapacity),\n        createdBy: loggedInUser.uid,\n        isDiscoverable: isDiscoverable,\n        createdAt: new Date(),\n        playerIDs: initialPlayerIDs, \n        players: initialPlayers       \n      });\n\n      await addDoc(collection(db, \"chats\"), {\n        type: 'roster', \n        rosterId: rosterRef.id,\n        name: `${rosterName} (${season})`,\n        participants: [loggedInUser.uid],\n        visibleTo: [loggedInUser.uid],\n        participantDetails: [{\n          uid: loggedInUser.uid,\n          name: loggedInUser.playerName,\n          email: loggedInUser.email,\n          photoURL: loggedInUser.photoURL || \"\"\n        }],\n        unreadCounts: { [loggedInUser.uid]: 0 }, \n        createdAt: serverTimestamp(),\n        lastMessage: \"Team chat created\",\n        lastMessageTime: serverTimestamp()\n      });\n\n      if (groupCreationData && groupCreationData.createGroup) {\n          await addDoc(collection(db, \"groups\"), {\n            name: groupCreationData.groupName || rosterName,\n            description: `Official group for ${rosterName} (${season})`,\n            isPublic: false, \n            createdBy: loggedInUser.uid,\n            associatedRosterId: rosterRef.id, \n            createdAt: serverTimestamp(),\n            members: [loggedInUser.uid],\n            memberDetails: [{\n              uid: loggedInUser.uid,\n              name: loggedInUser.playerName,\n              email: loggedInUser.email,\n              photoURL: loggedInUser.photoURL || \"\",\n              role: 'owner' \n            }]\n          });\n      }\n\n      return true;\n    } catch (error) {\n      console.error(\"Error creating roster:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const fetchRosters = async () => {\n    try {\n      const querySnapshot = await getDocs(collection(db, \"rosters\"));\n      return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n    } catch (error) {\n      console.error(\"Error fetching rosters:\", error);\n      return [];\n    }\n  };\n\n  const deleteRoster = async (rosterId) => {\n    if (!isManager()) return false;\n    try {\n      await deleteDoc(doc(db, \"rosters\", rosterId));\n\n      const chatsRef = collection(db, \"chats\");\n      const q = query(chatsRef, where(\"rosterId\", \"==\", rosterId));\n      const querySnapshot = await getDocs(q);\n\n      const batchPromises = querySnapshot.docs.map(async (chatDoc) => {\n          const systemMessage = \"This team has been disbanded by the manager. This chat is now a regular group.\";\n          \n          await addDoc(collection(db, \"chats\", chatDoc.id, \"messages\"), {\n              text: systemMessage,\n              type: 'system',\n              createdAt: serverTimestamp()\n          });\n\n          await updateDoc(chatDoc.ref, {\n              type: 'group',\n              rosterId: deleteField(),\n              lastMessage: systemMessage, \n              lastMessageTime: serverTimestamp() \n          });\n      });\n\n      await Promise.all(batchPromises);\n      return true;\n    } catch (error) {\n      console.error(\"Error deleting roster:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const addPlayerToRoster = async (rosterId, playerEmail) => {\n    if (!isManager()) return false;\n    \n    try {\n      const usersRef = collection(db, \"users\");\n      const q = query(usersRef, where(\"email\", \"==\", playerEmail));\n      const querySnapshot = await getDocs(q);\n\n      if (querySnapshot.empty) {\n        alert(\"No player found with that email address.\");\n        return false;\n      }\n\n      const playerDoc = querySnapshot.docs[0];\n      const playerData = playerDoc.data();\n\n      const playerSummary = {\n        uid: playerDoc.id,\n        playerName: playerData.playerName || \"Unknown\",\n        email: playerData.email,\n        photoURL: playerData.photoURL || \"\"\n      };\n\n      const rosterRef = doc(db, \"rosters\", rosterId);\n      await updateDoc(rosterRef, {\n        playerIDs: arrayUnion(playerDoc.id),\n        players: arrayUnion(playerSummary) \n      });\n\n      const chatsRef = collection(db, \"chats\");\n      const chatQ = query(chatsRef, where(\"rosterId\", \"==\", rosterId));\n      const chatSnapshot = await getDocs(chatQ);\n\n      if (!chatSnapshot.empty) {\n        const chatDoc = chatSnapshot.docs[0];\n        await setDoc(chatDoc.ref, {\n          participants: arrayUnion(playerDoc.id),\n          visibleTo: arrayUnion(playerDoc.id),\n          participantDetails: arrayUnion(playerSummary),\n          unreadCounts: { [playerDoc.id]: 0 } \n        }, { merge: true });\n      }\n      return true;\n\n    } catch (error) {\n      console.error(\"Error adding player:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const removePlayerFromRoster = async (rosterId, playerSummary) => {\n    if (!isManager()) return false;\n    \n    try {\n      const rosterRef = doc(db, \"rosters\", rosterId);\n      await updateDoc(rosterRef, {\n        playerIDs: arrayRemove(playerSummary.uid),\n        players: arrayRemove(playerSummary)\n      });\n\n      const chatsRef = collection(db, \"chats\");\n      const chatQ = query(chatsRef, where(\"rosterId\", \"==\", rosterId));\n      const chatSnapshot = await getDocs(chatQ);\n\n      if (!chatSnapshot.empty) {\n        const chatDoc = chatSnapshot.docs[0];\n        await updateDoc(chatDoc.ref, {\n          participants: arrayRemove(playerSummary.uid),\n          visibleTo: arrayRemove(playerSummary.uid),\n          participantDetails: arrayRemove(playerSummary)\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Error removing player:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const fetchUserRosters = async (uid) => {\n    try {\n      const rostersRef = collection(db, \"rosters\");\n      const q = query(rostersRef, where(\"playerIDs\", \"array-contains\", uid));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n    } catch (error) {\n      console.error(\"Error fetching user rosters:\", error);\n      return [];\n    }\n  };\n\n  const createEvent = async (rosterId, eventData) => {\n    try {\n      await addDoc(collection(db, \"rosters\", rosterId, \"events\"), {\n        ...eventData,\n        createdAt: new Date()\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating event:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const fetchEvents = async (rosterId) => {\n    try {\n      const eventsRef = collection(db, \"rosters\", rosterId, \"events\");\n      const q = query(eventsRef, orderBy(\"dateTime\", \"asc\"));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n    } catch (error) {\n      console.error(\"Error fetching events:\", error);\n      return [];\n    }\n  };\n\n  const deleteEvent = async (rosterId, eventId) => {\n    if (!isManager()) return false;\n    try {\n      await deleteDoc(doc(db, \"rosters\", rosterId, \"events\", eventId));\n      return true;\n    } catch (error) {\n      console.error(\"Error deleting event:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const fetchAllUserEvents = async (uid) => {\n    try {\n      const rosters = await fetchUserRosters(uid);\n      let allEvents = [];\n      for (const roster of rosters) {\n        const eventsRef = collection(db, \"rosters\", roster.id, \"events\");\n        const q = query(eventsRef); \n        const querySnapshot = await getDocs(q);\n        \n        const rosterEvents = querySnapshot.docs.map(doc => ({\n          id: doc.id,\n          rosterName: roster.name, \n          ...doc.data()\n        }));\n        allEvents = [...allEvents, ...rosterEvents];\n      }\n      allEvents.sort((a, b) => new Date(a.dateTime) - new Date(b.dateTime));\n      return allEvents;\n    } catch (error) {\n      console.error(\"Error fetching all events:\", error);\n      return [];\n    }\n  };\n\n  const createGroup = async (groupData) => {\n     try {\n      await addDoc(collection(db, \"groups\"), {\n        ...groupData,\n        createdBy: loggedInUser.uid,\n        createdAt: serverTimestamp(),\n        members: [loggedInUser.uid], \n        memberDetails: [{\n          uid: loggedInUser.uid,\n          name: loggedInUser.playerName,\n          email: loggedInUser.email,\n          photoURL: loggedInUser.photoURL || \"\",\n          role: 'owner' \n        }]\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating group:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const fetchUserGroups = async (uid) => {\n    try {\n      const groupsRef = collection(db, \"groups\");\n      const q = query(groupsRef, where(\"members\", \"array-contains\", uid));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n    } catch (error) {\n      console.error(\"Error fetching groups:\", error);\n      return [];\n    }\n  };\n\n  const createGroupPost = async (groupId, text, imageUrl = null) => {\n     try {\n      await addDoc(collection(db, \"groups\", groupId, \"posts\"), {\n        text: text,\n        imageUrl: imageUrl,\n        authorId: loggedInUser.uid,\n        authorName: loggedInUser.playerName,\n        authorPhoto: loggedInUser.photoURL || \"\",\n        createdAt: serverTimestamp(),\n        replies: [] \n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating post:\", error);\n      return false;\n    }\n  };\n\n  const addGroupMembers = async (groupId, emails) => {\n    try {\n      const groupRef = doc(db, \"groups\", groupId);\n      const groupSnap = await getDoc(groupRef);\n      \n      if (!groupSnap.exists()) return false;\n      \n      const groupData = groupSnap.data();\n      const myMemberDetails = groupData.memberDetails.find(m => m.uid === loggedInUser.uid);\n      \n      if (!myMemberDetails || (myMemberDetails.role !== 'owner' && myMemberDetails.role !== 'admin')) {\n        alert(\"Only Owners and Admins can add members.\");\n        return false;\n      }\n\n      const usersRef = collection(db, \"users\");\n      const newMembers = [];\n      const newMemberIds = [];\n\n      for (const email of emails) {\n        const q = query(usersRef, where(\"email\", \"==\", email));\n        const snapshot = await getDocs(q);\n        \n        if (!snapshot.empty) {\n          const userDoc = snapshot.docs[0];\n          const userData = userDoc.data();\n          \n          if (!groupData.members.includes(userDoc.id)) {\n             newMemberIds.push(userDoc.id);\n             newMembers.push({\n               uid: userDoc.id,\n               name: userData.playerName || \"Unknown\",\n               email: userData.email,\n               photoURL: userData.photoURL || \"\",\n               role: 'member'\n             });\n          }\n        }\n      }\n\n      if (newMemberIds.length === 0) {\n        return true; \n      }\n\n      await updateDoc(groupRef, {\n        members: arrayUnion(...newMemberIds),\n        memberDetails: arrayUnion(...newMembers)\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error adding group members:\", error);\n      alert(\"Error adding members: \" + error.message);\n      return false;\n    }\n  };\n\n  const updateGroupMemberRole = async (groupId, memberUid, newRole, currentMemberDetails) => {\n    try {\n      const groupRef = doc(db, \"groups\", groupId);\n      const updatedMemberDetails = currentMemberDetails.map(member => {\n        if (member.uid === memberUid) {\n          return { ...member, role: newRole };\n        }\n        return member;\n      });\n      await updateDoc(groupRef, { memberDetails: updatedMemberDetails });\n      return true;\n    } catch (error) {\n      console.error(\"Error updating role:\", error);\n      alert(\"Error updating role: \" + error.message);\n      return false;\n    }\n  };\n\n  const transferGroupOwnership = async (groupId, newOwnerUid, currentMemberDetails) => {\n    try {\n      const groupRef = doc(db, \"groups\", groupId);\n      const updatedMemberDetails = currentMemberDetails.map(member => {\n        if (member.uid === loggedInUser.uid) {\n          return { ...member, role: 'admin' }; \n        }\n        if (member.uid === newOwnerUid) {\n          return { ...member, role: 'owner' };\n        }\n        return member;\n      });\n      await updateDoc(groupRef, { memberDetails: updatedMemberDetails });\n      return true;\n    } catch (error) {\n      console.error(\"Error transferring ownership:\", error);\n      alert(\"Error transferring ownership: \" + error.message);\n      return false;\n    }\n  };\n\n  const removeGroupMember = async (groupId, memberUid, currentMemberDetails, currentMembers) => {\n    try {\n      const groupRef = doc(db, \"groups\", groupId);\n      const updatedMemberDetails = currentMemberDetails.filter(m => m.uid !== memberUid);\n      const updatedMembers = currentMembers.filter(uid => uid !== memberUid);\n\n      await updateDoc(groupRef, {\n        memberDetails: updatedMemberDetails,\n        members: updatedMembers\n      });\n      \n      return true;\n    } catch (error) {\n      console.error(\"Error removing member:\", error);\n      alert(\"Error removing member: \" + error.message);\n      return false;\n    }\n  };\n\n  const subscribeToIncomingRequests = (callback) => {\n    if (!isManager()) return () => {};\n    const requestsRef = collection(db, \"rosterRequests\");\n    const q = query(requestsRef, where(\"managerId\", \"==\", loggedInUser.uid));\n    return onSnapshot(q, (snapshot) => {\n      const requests = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n      callback(requests);\n    });\n  };\n\n  const subscribeToUserRequests = (callback) => {\n    if (!loggedInUser) return () => {};\n    const requestsRef = collection(db, \"rosterRequests\");\n    const q = query(requestsRef, where(\"userId\", \"==\", loggedInUser.uid));\n    return onSnapshot(q, (snapshot) => {\n      const requests = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n      callback(requests);\n    });\n  };\n\n  const subscribeToDiscoverableRosters = (callback) => {\n    const rostersRef = collection(db, \"rosters\");\n    const q = query(rostersRef, where(\"isDiscoverable\", \"==\", true));\n    return onSnapshot(q, (snapshot) => {\n      const rosters = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n      callback(rosters);\n    });\n  };\n\n  const submitJoinRequest = async (rosterId, rosterName, managerId) => {\n    try {\n       const requestsRef = collection(db, \"rosterRequests\");\n       const q = query(\n         requestsRef, \n         where(\"rosterId\", \"==\", rosterId),\n         where(\"userId\", \"==\", loggedInUser.uid)\n       );\n       const existing = await getDocs(q);\n       if (!existing.empty) {\n         alert(\"You have already sent a request for this team.\");\n         return false;\n       }\n\n       await addDoc(requestsRef, {\n         rosterId,\n         rosterName,\n         managerId,\n         userId: loggedInUser.uid,\n         userName: loggedInUser.playerName,\n         userEmail: loggedInUser.email,\n         status: 'pending',\n         createdAt: serverTimestamp()\n       });\n       return true;\n    } catch (error) {\n      console.error(\"Error submitting request:\", error);\n      alert(\"Failed to submit request: \" + error.message);\n      return false;\n    }\n  };\n\n  const fetchIncomingRequests = async () => {\n    if (!isManager()) return [];\n    try {\n      const requestsRef = collection(db, \"rosterRequests\");\n      const q = query(requestsRef, where(\"managerId\", \"==\", loggedInUser.uid));\n      const snapshot = await getDocs(q);\n      return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n    } catch (error) {\n      console.error(\"Error fetching incoming requests:\", error);\n      return [];\n    }\n  };\n\n  const fetchUserRequests = async () => {\n    try {\n      const requestsRef = collection(db, \"rosterRequests\");\n      const q = query(requestsRef, where(\"userId\", \"==\", loggedInUser.uid));\n      const snapshot = await getDocs(q);\n      return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n    } catch (error) {\n      console.error(\"Error fetching user requests:\", error);\n      return [];\n    }\n  };\n  \n  const fetchDiscoverableRosters = async () => {\n    try {\n      const rostersRef = collection(db, \"rosters\");\n      const q = query(rostersRef, where(\"isDiscoverable\", \"==\", true));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n    } catch (error) {\n      console.error(\"Error fetching discoverable rosters:\", error);\n      return [];\n    }\n  };\n\n  const fetchPlayerDetails = async (uid) => {\n    try {\n        const userDocRef = doc(db, \"users\", uid);\n        const userSnap = await getDoc(userDocRef);\n        \n        if (!userSnap.exists()) return null;\n\n        const soccerDocRef = doc(db, \"users\", uid, \"sportsDetails\", \"soccer\");\n        const soccerSnap = await getDoc(soccerDocRef);\n\n        return {\n            ...userSnap.data(),\n            soccerDetails: soccerSnap.exists() ? soccerSnap.data() : null\n        };\n    } catch (error) {\n        console.error(\"Error fetching player details:\", error);\n        return null;\n    }\n  };\n\n  const respondToRequest = async (request, action, targetGroupId = null) => {\n      if (!isManager()) return false;\n      \n      try {\n        if (action === 'approve') {\n            const userDocRef = doc(db, \"users\", request.userId);\n            const userSnap = await getDoc(userDocRef);\n            \n            if (!userSnap.exists()) {\n                alert(\"User no longer exists.\");\n                await deleteDoc(doc(db, \"rosterRequests\", request.id));\n                return false;\n            }\n            \n            const userData = userSnap.data();\n            const playerSummary = {\n                uid: request.userId,\n                playerName: userData.playerName || \"Unknown\",\n                email: userData.email,\n                photoURL: userData.photoURL || \"\"\n            };\n\n            // 1. Add to Roster\n            const rosterRef = doc(db, \"rosters\", request.rosterId);\n            await updateDoc(rosterRef, {\n                playerIDs: arrayUnion(request.userId),\n                players: arrayUnion(playerSummary)\n            });\n\n            // 2. Add to Chat\n            const chatsRef = collection(db, \"chats\");\n            const chatQ = query(chatsRef, where(\"rosterId\", \"==\", request.rosterId));\n            const chatSnapshot = await getDocs(chatQ);\n\n            if (!chatSnapshot.empty) {\n                const chatDoc = chatSnapshot.docs[0];\n                await setDoc(chatDoc.ref, {\n                participants: arrayUnion(request.userId),\n                visibleTo: arrayUnion(request.userId),\n                participantDetails: arrayUnion(playerSummary),\n                unreadCounts: { [request.userId]: 0 } \n                }, { merge: true });\n            }\n\n            // 3. Add to Targeted Group (if selected)\n            if (targetGroupId) {\n                const groupRef = doc(db, \"groups\", targetGroupId);\n                const groupSnap = await getDoc(groupRef);\n                \n                if (groupSnap.exists()) {\n                    await updateDoc(groupRef, {\n                        members: arrayUnion(request.userId),\n                        memberDetails: arrayUnion({\n                            uid: request.userId,\n                            name: userData.playerName || \"Unknown\",\n                            email: userData.email,\n                            photoURL: userData.photoURL || \"\",\n                            role: 'member'\n                        })\n                    });\n                }\n            }\n        }\n        \n        await deleteDoc(doc(db, \"rosterRequests\", request.id));\n        return true;\n      } catch (error) {\n          console.error(\"Error responding to request:\", error);\n          alert(\"Error: \" + error.message);\n          return false;\n      }\n  };\n\n  // --- NEW FEEDBACK FUNCTIONS ---\n\n  const createFeedback = async (data) => {\n    try {\n      await addDoc(collection(db, \"feedback\"), {\n        ...data,\n        authorId: loggedInUser.uid,\n        authorName: loggedInUser.playerName,\n        status: 'Proposed', // Default status\n        developerNotes: '',\n        votes: 0,\n        voters: [], // Array to track who voted\n        createdAt: serverTimestamp()\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating feedback:\", error);\n      alert(\"Error submitting feedback: \" + error.message);\n      return false;\n    }\n  };\n\n  const subscribeToFeedback = (callback) => {\n    // Order by votes descending (highest votes first)\n    const feedbackRef = collection(db, \"feedback\");\n    const q = query(feedbackRef, orderBy(\"votes\", \"desc\"));\n    \n    return onSnapshot(q, (snapshot) => {\n      const items = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n      callback(items);\n    });\n  };\n\n  const voteForFeedback = async (feedbackId) => {\n    if (!loggedInUser) return;\n    try {\n      const feedbackRef = doc(db, \"feedback\", feedbackId);\n      const feedbackSnap = await getDoc(feedbackRef);\n      \n      if (feedbackSnap.exists()) {\n        const data = feedbackSnap.data();\n        // Check if user already voted\n        if (data.voters && data.voters.includes(loggedInUser.uid)) {\n          alert(\"You have already voted for this item.\");\n          return false;\n        }\n\n        await updateDoc(feedbackRef, {\n          votes: increment(1),\n          voters: arrayUnion(loggedInUser.uid)\n        });\n        return true;\n      }\n    } catch (error) {\n      console.error(\"Error voting:\", error);\n      return false;\n    }\n  };\n\n  // --- VALUE OBJECT ---\n  const value = {\n    loggedInUser,\n    soccerDetails,\n    isLoading,\n    needsReauth,\n    setNeedsReauth,\n    signIn,\n    signUp,\n    signOutUser,\n    updateProfile,\n    reauthenticate,\n    updateSoccerDetails,\n    isManager,\n    createRoster,\n    fetchRosters,\n    deleteRoster,\n    addPlayerToRoster,\n    removePlayerFromRoster,\n    fetchUserRosters,\n    createEvent,\n    fetchEvents,\n    deleteEvent,\n    fetchAllUserEvents,\n    uploadImage,\n    createGroup,\n    fetchUserGroups,\n    createGroupPost,\n    addGroupMembers,\n    updateGroupMemberRole,\n    transferGroupOwnership,\n    removeGroupMember,\n    fetchDiscoverableRosters, \n    submitJoinRequest,        \n    fetchIncomingRequests,    \n    fetchUserRequests,        \n    respondToRequest,\n    subscribeToIncomingRequests,\n    subscribeToUserRequests,\n    subscribeToDiscoverableRosters,\n    fetchPlayerDetails,\n    createFeedback,\n    subscribeToFeedback,\n    voteForFeedback\n  };\n\n  return (\n    <AuthContext.Provider value={value}>\n      {children}\n    </AuthContext.Provider>\n  );\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}