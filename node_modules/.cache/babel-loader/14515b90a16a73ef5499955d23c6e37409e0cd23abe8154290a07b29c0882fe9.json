{"ast":null,"code":"var _jsxFileName = \"/Users/dbroxton/Documents/Projects/soccer-management-app/src/context/AuthContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport { onAuthStateChanged, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, updateEmail, EmailAuthProvider, reauthenticateWithCredential } from \"firebase/auth\";\nimport { doc, getDoc, setDoc, updateDoc, collection, addDoc, getDocs, deleteDoc, query, where, arrayUnion, arrayRemove, orderBy, serverTimestamp } from \"firebase/firestore\";\nimport { auth, db } from \"../firebase\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AuthContext = /*#__PURE__*/createContext();\nexport const useAuth = () => {\n  _s();\n  return useContext(AuthContext);\n};\n_s(useAuth, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const AuthProvider = ({\n  children\n}) => {\n  _s2();\n  const [loggedInUser, setLoggedInUser] = useState(null);\n  const [soccerDetails, setSoccerDetails] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [needsReauth, setNeedsReauth] = useState(false);\n  useEffect(() => {\n    const unsubscribe = onAuthStateChanged(auth, async user => {\n      if (user) {\n        const userDocRef = doc(db, \"users\", user.uid);\n        const userDoc = await getDoc(userDocRef);\n        const soccerDocRef = doc(db, \"users\", user.uid, \"sportsDetails\", \"soccer\");\n        const soccerDoc = await getDoc(soccerDocRef);\n        if (userDoc.exists()) {\n          setLoggedInUser(userDoc.data());\n        } else {\n          setLoggedInUser(null);\n        }\n        if (soccerDoc.exists()) {\n          setSoccerDetails(soccerDoc.data());\n        } else {\n          setSoccerDetails(null);\n        }\n      } else {\n        setLoggedInUser(null);\n        setSoccerDetails(null);\n      }\n      setIsLoading(false);\n    });\n    return () => unsubscribe();\n  }, []);\n\n  // ... (signIn, signUp, signOutUser, updateProfile, reauthenticate, updateSoccerDetails, isManager REMAIN UNCHANGED) ...\n\n  const signIn = async (email, password) => {\n    setIsLoading(true);\n    try {\n      const userCredential = await signInWithEmailAndPassword(auth, email, password);\n      const user = userCredential.user;\n      const userDocRef = doc(db, \"users\", user.uid);\n      const userDoc = await getDoc(userDocRef);\n      const soccerDocRef = doc(db, \"users\", user.uid, \"sportsDetails\", \"soccer\");\n      const soccerDoc = await getDoc(soccerDocRef);\n      if (soccerDoc.exists()) {\n        setSoccerDetails(soccerDoc.data());\n      } else {\n        setSoccerDetails(null);\n      }\n      if (userDoc.exists()) {\n        setLoggedInUser(userDoc.data());\n      } else {\n        alert(\"Authentication successful, but no profile was found.\");\n        setLoggedInUser(null);\n      }\n    } catch (error) {\n      console.error(\"Error signing in:\", error);\n      alert(\"Error: \" + error.message);\n    }\n    setIsLoading(false);\n  };\n  const signUp = async formData => {\n    if (formData.password.length < 6) {\n      alert(\"Password must be at least 6 characters long.\");\n      return;\n    }\n    try {\n      const userCredential = await createUserWithEmailAndPassword(auth, formData.email, formData.password);\n      const user = userCredential.user;\n      const userProfileData = {\n        uid: user.uid,\n        playerName: formData.playerName,\n        email: formData.email,\n        phone: formData.phone,\n        address: formData.address,\n        notificationPreference: formData.notificationPreference,\n        comments: formData.comments,\n        role: 'player'\n      };\n      await setDoc(doc(db, \"users\", user.uid), userProfileData);\n      setLoggedInUser(userProfileData);\n    } catch (error) {\n      console.error(\"Error signing up:\", error);\n      alert(\"Error: \" + error.message);\n    }\n  };\n  const signOutUser = async () => {\n    try {\n      await signOut(auth);\n      setLoggedInUser(null);\n      setSoccerDetails(null);\n    } catch (error) {\n      console.error(\"Error signing out:\", error);\n      alert(\"Error: \" + error.message);\n    }\n  };\n  const updateProfile = async profileData => {\n    if (!loggedInUser) return;\n    if (profileData.email !== loggedInUser.email) {\n      try {\n        await updateEmail(auth.currentUser, profileData.email);\n      } catch (error) {\n        if (error.code === 'auth/requires-recent-login') {\n          setNeedsReauth(true);\n        } else {\n          alert(\"Error: \" + error.message);\n        }\n        return;\n      }\n    }\n    try {\n      const dataToUpdate = {\n        playerName: profileData.playerName,\n        phone: profileData.phone,\n        address: profileData.address,\n        notificationPreference: profileData.notificationPreference,\n        comments: profileData.comments,\n        email: profileData.email\n      };\n      const userDocRef = doc(db, \"users\", loggedInUser.uid);\n      await updateDoc(userDocRef, dataToUpdate);\n      setLoggedInUser(prevUser => ({\n        ...prevUser,\n        ...dataToUpdate\n      }));\n      alert(\"Profile successfully updated!\");\n      return true;\n    } catch (error) {\n      alert(\"Error saving profile: \" + error.message);\n      return false;\n    }\n  };\n  const reauthenticate = async (password, newEmail) => {\n    if (!auth.currentUser || !password) return;\n    try {\n      const credential = EmailAuthProvider.credential(auth.currentUser.email, password);\n      await reauthenticateWithCredential(auth.currentUser, credential);\n      await updateEmail(auth.currentUser, newEmail);\n      const userDocRef = doc(db, \"users\", loggedInUser.uid);\n      await updateDoc(userDocRef, {\n        email: newEmail\n      });\n      setLoggedInUser(prevUser => ({\n        ...prevUser,\n        email: newEmail\n      }));\n      alert(\"Email successfully updated!\");\n      setNeedsReauth(false);\n      return true;\n    } catch (error) {\n      alert(\"Error: Incorrect password or another error occurred. \" + error.message);\n      return false;\n    }\n  };\n  const updateSoccerDetails = async soccerData => {\n    if (!loggedInUser) return;\n    try {\n      const soccerDataToSave = {\n        ...soccerData,\n        currentRosters: soccerData.currentRosters.split(',').map(item => item.trim()),\n        rosterJerseysOwned: soccerData.rosterJerseysOwned.split(',').map(item => item.trim()),\n        playerNumber: Number(soccerData.playerNumber) || 0\n      };\n      const soccerDocRef = doc(db, \"users\", loggedInUser.uid, \"sportsDetails\", \"soccer\");\n      await setDoc(soccerDocRef, soccerDataToSave);\n      setSoccerDetails(soccerDataToSave);\n      alert(\"Soccer info saved!\");\n      return true;\n    } catch (error) {\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const isManager = () => {\n    return loggedInUser && loggedInUser.role === 'manager';\n  };\n\n  // --- Roster Management (UPDATED) ---\n\n  const createRoster = async (rosterName, season, maxCapacity) => {\n    if (!isManager()) {\n      alert(\"Only managers can create rosters.\");\n      return false;\n    }\n    try {\n      // 1. Create Roster\n      const rosterRef = await addDoc(collection(db, \"rosters\"), {\n        name: rosterName,\n        season: season,\n        maxCapacity: Number(maxCapacity),\n        createdBy: loggedInUser.uid,\n        createdAt: new Date(),\n        playerIDs: [],\n        players: []\n      });\n\n      // 2. NEW: Create Linked Persistent Chat\n      // Managers are auto-added to the chat\n      await addDoc(collection(db, \"chats\"), {\n        type: 'roster',\n        // Special type\n        rosterId: rosterRef.id,\n        // Link back to roster\n        name: `${rosterName} (${season})`,\n        // Team Name\n        participants: [loggedInUser.uid],\n        visibleTo: [loggedInUser.uid],\n        // Visible to manager initially\n        participantDetails: [{\n          uid: loggedInUser.uid,\n          name: loggedInUser.playerName,\n          email: loggedInUser.email\n        }],\n        createdAt: serverTimestamp(),\n        lastMessage: \"Team chat created\",\n        lastMessageTime: serverTimestamp()\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating roster:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const fetchRosters = async () => {\n    try {\n      const querySnapshot = await getDocs(collection(db, \"rosters\"));\n      return querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error(\"Error fetching rosters:\", error);\n      return [];\n    }\n  };\n  const deleteRoster = async rosterId => {\n    if (!isManager()) return false;\n    try {\n      // Note: In a real app, we should also delete the linked Chat document here.\n      await deleteDoc(doc(db, \"rosters\", rosterId));\n      return true;\n    } catch (error) {\n      console.error(\"Error deleting roster:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const addPlayerToRoster = async (rosterId, playerEmail) => {\n    if (!isManager()) return false;\n    try {\n      const usersRef = collection(db, \"users\");\n      const q = query(usersRef, where(\"email\", \"==\", playerEmail));\n      const querySnapshot = await getDocs(q);\n      if (querySnapshot.empty) {\n        alert(\"No player found with that email address.\");\n        return false;\n      }\n      const playerDoc = querySnapshot.docs[0];\n      const playerData = playerDoc.data();\n      const playerSummary = {\n        uid: playerDoc.id,\n        playerName: playerData.playerName || \"Unknown\",\n        email: playerData.email\n      };\n\n      // 1. Update Roster\n      const rosterRef = doc(db, \"rosters\", rosterId);\n      await updateDoc(rosterRef, {\n        playerIDs: arrayUnion(playerDoc.id),\n        players: arrayUnion(playerSummary)\n      });\n\n      // 2. NEW: Update Linked Chat (Add player to chat)\n      // Find the chat associated with this roster\n      const chatsRef = collection(db, \"chats\");\n      const chatQ = query(chatsRef, where(\"rosterId\", \"==\", rosterId));\n      const chatSnapshot = await getDocs(chatQ);\n      if (!chatSnapshot.empty) {\n        const chatDoc = chatSnapshot.docs[0];\n        await updateDoc(chatDoc.ref, {\n          participants: arrayUnion(playerDoc.id),\n          visibleTo: arrayUnion(playerDoc.id),\n          // Make it visible immediately\n          participantDetails: arrayUnion(playerSummary)\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Error adding player:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const removePlayerFromRoster = async (rosterId, playerSummary) => {\n    if (!isManager()) return false;\n    try {\n      // 1. Update Roster\n      const rosterRef = doc(db, \"rosters\", rosterId);\n      await updateDoc(rosterRef, {\n        playerIDs: arrayRemove(playerSummary.uid),\n        players: arrayRemove(playerSummary)\n      });\n\n      // 2. NEW: Update Linked Chat (Remove player from chat)\n      const chatsRef = collection(db, \"chats\");\n      const chatQ = query(chatsRef, where(\"rosterId\", \"==\", rosterId));\n      const chatSnapshot = await getDocs(chatQ);\n      if (!chatSnapshot.empty) {\n        const chatDoc = chatSnapshot.docs[0];\n        await updateDoc(chatDoc.ref, {\n          participants: arrayRemove(playerSummary.uid),\n          visibleTo: arrayRemove(playerSummary.uid),\n          participantDetails: arrayRemove(playerSummary)\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Error removing player:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  // ... (fetchUserRosters, createEvent, fetchEvents, deleteEvent, fetchAllUserEvents REMAIN UNCHANGED) ...\n\n  const fetchUserRosters = async uid => {\n    try {\n      const rostersRef = collection(db, \"rosters\");\n      const q = query(rostersRef, where(\"playerIDs\", \"array-contains\", uid));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error(\"Error fetching user rosters:\", error);\n      return [];\n    }\n  };\n  const createEvent = async (rosterId, eventData) => {\n    try {\n      await addDoc(collection(db, \"rosters\", rosterId, \"events\"), {\n        ...eventData,\n        createdAt: new Date()\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating event:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const fetchEvents = async rosterId => {\n    try {\n      const eventsRef = collection(db, \"rosters\", rosterId, \"events\");\n      const q = query(eventsRef, orderBy(\"dateTime\", \"asc\"));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error(\"Error fetching events:\", error);\n      return [];\n    }\n  };\n  const deleteEvent = async (rosterId, eventId) => {\n    if (!isManager()) return false;\n    try {\n      await deleteDoc(doc(db, \"rosters\", rosterId, \"events\", eventId));\n      return true;\n    } catch (error) {\n      console.error(\"Error deleting event:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const fetchAllUserEvents = async uid => {\n    try {\n      const rosters = await fetchUserRosters(uid);\n      let allEvents = [];\n      for (const roster of rosters) {\n        const eventsRef = collection(db, \"rosters\", roster.id, \"events\");\n        const q = query(eventsRef);\n        const querySnapshot = await getDocs(q);\n        const rosterEvents = querySnapshot.docs.map(doc => ({\n          id: doc.id,\n          rosterName: roster.name,\n          ...doc.data()\n        }));\n        allEvents = [...allEvents, ...rosterEvents];\n      }\n      allEvents.sort((a, b) => new Date(a.dateTime) - new Date(b.dateTime));\n      return allEvents;\n    } catch (error) {\n      console.error(\"Error fetching all events:\", error);\n      return [];\n    }\n  };\n\n  // --- UPDATED: Flexible Chat Functions ---\n\n  // 1. Create a new chat (DM or Group)\n  // NEW: Initializes visibleTo\n  const createChat = async (participantEmails, chatName = \"\") => {\n    try {\n      const usersRef = collection(db, \"users\");\n      const participants = [];\n      const participantIds = [loggedInUser.uid];\n      participants.push({\n        uid: loggedInUser.uid,\n        name: loggedInUser.playerName,\n        email: loggedInUser.email\n      });\n      for (const email of participantEmails) {\n        if (email === loggedInUser.email) continue;\n        const q = query(usersRef, where(\"email\", \"==\", email));\n        const snapshot = await getDocs(q);\n        if (!snapshot.empty) {\n          const userDoc = snapshot.docs[0];\n          const userData = userDoc.data();\n          participantIds.push(userDoc.id);\n          participants.push({\n            uid: userDoc.id,\n            name: userData.playerName || \"Unknown\",\n            email: userData.email\n          });\n        }\n      }\n      if (participantIds.length < 2) {\n        alert(\"Could not find any valid users to chat with.\");\n        return false;\n      }\n      await addDoc(collection(db, \"chats\"), {\n        type: participantIds.length > 2 ? 'group' : 'dm',\n        name: chatName || (participants.length === 2 ? participants[1].name : \"Group Chat\"),\n        participants: participantIds,\n        visibleTo: participantIds,\n        // NEW: All participants see it initially\n        participantDetails: participants,\n        createdAt: serverTimestamp(),\n        lastMessage: \"Chat created\",\n        lastMessageTime: serverTimestamp()\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating chat:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  // 2. Send a message\n  // NEW: Updates visibleTo for \"Resurrection\"\n  const sendMessage = async (chatId, text, currentParticipants) => {\n    try {\n      await addDoc(collection(db, \"chats\", chatId, \"messages\"), {\n        text: text,\n        senderId: loggedInUser.uid,\n        senderName: loggedInUser.playerName,\n        createdAt: serverTimestamp()\n      });\n\n      // Update parent chat doc\n      const chatRef = doc(db, \"chats\", chatId);\n      await updateDoc(chatRef, {\n        lastMessage: text,\n        lastMessageTime: serverTimestamp(),\n        // NEW: Resurrection Logic\n        // Set visibleTo back to the full participants list so it reappears for everyone\n        visibleTo: currentParticipants\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error sending message:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  // 3. Fetch chats for the current user\n  // NEW: Queries 'visibleTo' instead of 'participants'\n  const fetchUserChats = async uid => {\n    try {\n      const chatsRef = collection(db, \"chats\");\n      // NEW: Only fetch chats where I am in the 'visibleTo' array\n      const q = query(chatsRef, where(\"visibleTo\", \"array-contains\", uid), orderBy(\"lastMessageTime\", \"desc\"));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error(\"Error fetching chats:\", error);\n      return [];\n    }\n  };\n\n  // NEW: Hide Chat Function\n  const hideChat = async (chatId, currentVisibleTo, chatType) => {\n    // Rule: Cannot hide/delete roster chats\n    if (chatType === 'roster') {\n      alert(\"Team Roster chats cannot be deleted.\");\n      return false;\n    }\n    try {\n      // Calculate the new visibility list (remove myself)\n      const newVisibleTo = currentVisibleTo.filter(uid => uid !== loggedInUser.uid);\n      if (newVisibleTo.length === 0) {\n        // If NO ONE can see it anymore, delete the chat document entirely (Cleanup)\n        await deleteDoc(doc(db, \"chats\", chatId));\n        console.log(\"Chat deleted permanently (no visible participants).\");\n      } else {\n        // Otherwise, just update the document to hide it for me\n        const chatRef = doc(db, \"chats\", chatId);\n        await updateDoc(chatRef, {\n          visibleTo: newVisibleTo\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Error hiding chat:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const value = {\n    loggedInUser,\n    soccerDetails,\n    isLoading,\n    needsReauth,\n    setNeedsReauth,\n    signIn,\n    signUp,\n    signOutUser,\n    updateProfile,\n    reauthenticate,\n    updateSoccerDetails,\n    isManager,\n    createRoster,\n    fetchRosters,\n    deleteRoster,\n    addPlayerToRoster,\n    removePlayerFromRoster,\n    fetchUserRosters,\n    createEvent,\n    fetchEvents,\n    deleteEvent,\n    fetchAllUserEvents,\n    createChat,\n    sendMessage,\n    fetchUserChats,\n    // NEW: Export hideChat\n    hideChat\n  };\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 619,\n    columnNumber: 5\n  }, this);\n};\n_s2(AuthProvider, \"5MPytths2y1fFmqpbAcpPs27WVo=\");\n_c = AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","onAuthStateChanged","signInWithEmailAndPassword","createUserWithEmailAndPassword","signOut","updateEmail","EmailAuthProvider","reauthenticateWithCredential","doc","getDoc","setDoc","updateDoc","collection","addDoc","getDocs","deleteDoc","query","where","arrayUnion","arrayRemove","orderBy","serverTimestamp","auth","db","jsxDEV","_jsxDEV","AuthContext","useAuth","_s","AuthProvider","children","_s2","loggedInUser","setLoggedInUser","soccerDetails","setSoccerDetails","isLoading","setIsLoading","needsReauth","setNeedsReauth","unsubscribe","user","userDocRef","uid","userDoc","soccerDocRef","soccerDoc","exists","data","signIn","email","password","userCredential","alert","error","console","message","signUp","formData","length","userProfileData","playerName","phone","address","notificationPreference","comments","role","signOutUser","updateProfile","profileData","currentUser","code","dataToUpdate","prevUser","reauthenticate","newEmail","credential","updateSoccerDetails","soccerData","soccerDataToSave","currentRosters","split","map","item","trim","rosterJerseysOwned","playerNumber","Number","isManager","createRoster","rosterName","season","maxCapacity","rosterRef","name","createdBy","createdAt","Date","playerIDs","players","type","rosterId","id","participants","visibleTo","participantDetails","lastMessage","lastMessageTime","fetchRosters","querySnapshot","docs","deleteRoster","addPlayerToRoster","playerEmail","usersRef","q","empty","playerDoc","playerData","playerSummary","chatsRef","chatQ","chatSnapshot","chatDoc","ref","removePlayerFromRoster","fetchUserRosters","rostersRef","createEvent","eventData","fetchEvents","eventsRef","deleteEvent","eventId","fetchAllUserEvents","rosters","allEvents","roster","rosterEvents","sort","a","b","dateTime","createChat","participantEmails","chatName","participantIds","push","snapshot","userData","sendMessage","chatId","text","currentParticipants","senderId","senderName","chatRef","fetchUserChats","hideChat","currentVisibleTo","chatType","newVisibleTo","filter","log","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/dbroxton/Documents/Projects/soccer-management-app/src/context/AuthContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect } from 'react';\nimport {\n  onAuthStateChanged,\n  signInWithEmailAndPassword,\n  createUserWithEmailAndPassword,\n  signOut,\n  updateEmail,\n  EmailAuthProvider,\n  reauthenticateWithCredential\n} from \"firebase/auth\";\nimport { \n  doc, getDoc, setDoc, updateDoc, collection, addDoc, getDocs, deleteDoc, \n  query, where, arrayUnion, arrayRemove, orderBy, serverTimestamp \n} from \"firebase/firestore\";\nimport { auth, db } from \"../firebase\"; \n\nconst AuthContext = createContext();\n\nexport const useAuth = () => {\n  return useContext(AuthContext);\n};\n\nexport const AuthProvider = ({ children }) => {\n  const [loggedInUser, setLoggedInUser] = useState(null);\n  const [soccerDetails, setSoccerDetails] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [needsReauth, setNeedsReauth] = useState(false);\n\n  useEffect(() => {\n    const unsubscribe = onAuthStateChanged(auth, async (user) => {\n      if (user) {\n        const userDocRef = doc(db, \"users\", user.uid);\n        const userDoc = await getDoc(userDocRef);\n        const soccerDocRef = doc(db, \"users\", user.uid, \"sportsDetails\", \"soccer\");\n        const soccerDoc = await getDoc(soccerDocRef);\n\n        if (userDoc.exists()) {\n          setLoggedInUser(userDoc.data());\n        } else {\n          setLoggedInUser(null);\n        }\n\n        if (soccerDoc.exists()) {\n          setSoccerDetails(soccerDoc.data());\n        } else {\n          setSoccerDetails(null);\n        }\n      } else {\n        setLoggedInUser(null);\n        setSoccerDetails(null);\n      }\n      setIsLoading(false);\n    });\n    return () => unsubscribe();\n  }, []); \n\n  // ... (signIn, signUp, signOutUser, updateProfile, reauthenticate, updateSoccerDetails, isManager REMAIN UNCHANGED) ...\n  \n  const signIn = async (email, password) => {\n    setIsLoading(true);\n    try {\n      const userCredential = await signInWithEmailAndPassword(auth, email, password);\n      const user = userCredential.user;\n      \n      const userDocRef = doc(db, \"users\", user.uid);\n      const userDoc = await getDoc(userDocRef);\n      const soccerDocRef = doc(db, \"users\", user.uid, \"sportsDetails\", \"soccer\");\n      const soccerDoc = await getDoc(soccerDocRef);\n\n      if (soccerDoc.exists()) {\n        setSoccerDetails(soccerDoc.data());\n      } else {\n        setSoccerDetails(null);\n      }\n\n      if (userDoc.exists()) {\n        setLoggedInUser(userDoc.data());\n      } else {\n        alert(\"Authentication successful, but no profile was found.\");\n        setLoggedInUser(null);\n      }\n    } catch (error) {\n      console.error(\"Error signing in:\", error);\n      alert(\"Error: \" + error.message);\n    }\n    setIsLoading(false);\n  };\n\n  const signUp = async (formData) => {\n    if (formData.password.length < 6) {\n      alert(\"Password must be at least 6 characters long.\");\n      return;\n    }\n    try {\n      const userCredential = await createUserWithEmailAndPassword(auth, formData.email, formData.password);\n      const user = userCredential.user;\n      \n      const userProfileData = {\n        uid: user.uid,\n        playerName: formData.playerName,\n        email: formData.email,\n        phone: formData.phone,\n        address: formData.address,\n        notificationPreference: formData.notificationPreference,\n        comments: formData.comments,\n        role: 'player'\n      };\n      \n      await setDoc(doc(db, \"users\", user.uid), userProfileData);\n      setLoggedInUser(userProfileData);\n    } catch (error) {\n      console.error(\"Error signing up:\", error);\n      alert(\"Error: \" + error.message);\n    }\n  };\n\n  const signOutUser = async () => {\n    try {\n      await signOut(auth);\n      setLoggedInUser(null);\n      setSoccerDetails(null);\n    } catch (error) {\n      console.error(\"Error signing out:\", error);\n      alert(\"Error: \" + error.message);\n    }\n  };\n\n  const updateProfile = async (profileData) => {\n    if (!loggedInUser) return;\n    if (profileData.email !== loggedInUser.email) {\n      try {\n        await updateEmail(auth.currentUser, profileData.email);\n      } catch (error) {\n        if (error.code === 'auth/requires-recent-login') {\n          setNeedsReauth(true); \n        } else {\n          alert(\"Error: \" + error.message);\n        }\n        return;\n      }\n    }\n    try {\n      const dataToUpdate = {\n        playerName: profileData.playerName,\n        phone: profileData.phone,\n        address: profileData.address,\n        notificationPreference: profileData.notificationPreference,\n        comments: profileData.comments,\n        email: profileData.email\n      };\n      \n      const userDocRef = doc(db, \"users\", loggedInUser.uid);\n      await updateDoc(userDocRef, dataToUpdate);\n      \n      setLoggedInUser(prevUser => ({\n        ...prevUser,\n        ...dataToUpdate\n      }));\n      \n      alert(\"Profile successfully updated!\");\n      return true; \n    } catch (error) {\n      alert(\"Error saving profile: \" + error.message);\n      return false;\n    }\n  };\n\n  const reauthenticate = async (password, newEmail) => {\n    if (!auth.currentUser || !password) return;\n    try {\n      const credential = EmailAuthProvider.credential(auth.currentUser.email, password);\n      await reauthenticateWithCredential(auth.currentUser, credential);\n      await updateEmail(auth.currentUser, newEmail);\n      const userDocRef = doc(db, \"users\", loggedInUser.uid);\n      await updateDoc(userDocRef, { email: newEmail });\n\n      setLoggedInUser(prevUser => ({\n        ...prevUser,\n        email: newEmail\n      }));\n\n      alert(\"Email successfully updated!\");\n      setNeedsReauth(false); \n      return true; \n    } catch (error) {\n      alert(\"Error: Incorrect password or another error occurred. \" + error.message);\n      return false;\n    }\n  };\n\n  const updateSoccerDetails = async (soccerData) => {\n    if (!loggedInUser) return;\n    try {\n      const soccerDataToSave = {\n        ...soccerData,\n        currentRosters: soccerData.currentRosters.split(',').map(item => item.trim()),\n        rosterJerseysOwned: soccerData.rosterJerseysOwned.split(',').map(item => item.trim()),\n        playerNumber: Number(soccerData.playerNumber) || 0,\n      };\n      \n      const soccerDocRef = doc(db, \"users\", loggedInUser.uid, \"sportsDetails\", \"soccer\");\n      await setDoc(soccerDocRef, soccerDataToSave);\n      \n      setSoccerDetails(soccerDataToSave); \n      alert(\"Soccer info saved!\");\n      return true; \n\n    } catch (error) {\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const isManager = () => {\n    return loggedInUser && loggedInUser.role === 'manager';\n  };\n\n  // --- Roster Management (UPDATED) ---\n\n  const createRoster = async (rosterName, season, maxCapacity) => {\n    if (!isManager()) {\n      alert(\"Only managers can create rosters.\");\n      return false;\n    }\n    try {\n      // 1. Create Roster\n      const rosterRef = await addDoc(collection(db, \"rosters\"), {\n        name: rosterName,\n        season: season,\n        maxCapacity: Number(maxCapacity),\n        createdBy: loggedInUser.uid,\n        createdAt: new Date(),\n        playerIDs: [],\n        players: [] \n      });\n\n      // 2. NEW: Create Linked Persistent Chat\n      // Managers are auto-added to the chat\n      await addDoc(collection(db, \"chats\"), {\n        type: 'roster', // Special type\n        rosterId: rosterRef.id, // Link back to roster\n        name: `${rosterName} (${season})`, // Team Name\n        participants: [loggedInUser.uid],\n        visibleTo: [loggedInUser.uid], // Visible to manager initially\n        participantDetails: [{\n          uid: loggedInUser.uid,\n          name: loggedInUser.playerName,\n          email: loggedInUser.email\n        }],\n        createdAt: serverTimestamp(),\n        lastMessage: \"Team chat created\",\n        lastMessageTime: serverTimestamp()\n      });\n\n      return true;\n    } catch (error) {\n      console.error(\"Error creating roster:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const fetchRosters = async () => {\n    try {\n      const querySnapshot = await getDocs(collection(db, \"rosters\"));\n      return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n    } catch (error) {\n      console.error(\"Error fetching rosters:\", error);\n      return [];\n    }\n  };\n\n  const deleteRoster = async (rosterId) => {\n    if (!isManager()) return false;\n    try {\n      // Note: In a real app, we should also delete the linked Chat document here.\n      await deleteDoc(doc(db, \"rosters\", rosterId));\n      return true;\n    } catch (error) {\n      console.error(\"Error deleting roster:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const addPlayerToRoster = async (rosterId, playerEmail) => {\n    if (!isManager()) return false;\n    \n    try {\n      const usersRef = collection(db, \"users\");\n      const q = query(usersRef, where(\"email\", \"==\", playerEmail));\n      const querySnapshot = await getDocs(q);\n\n      if (querySnapshot.empty) {\n        alert(\"No player found with that email address.\");\n        return false;\n      }\n\n      const playerDoc = querySnapshot.docs[0];\n      const playerData = playerDoc.data();\n\n      const playerSummary = {\n        uid: playerDoc.id,\n        playerName: playerData.playerName || \"Unknown\",\n        email: playerData.email\n      };\n\n      // 1. Update Roster\n      const rosterRef = doc(db, \"rosters\", rosterId);\n      await updateDoc(rosterRef, {\n        playerIDs: arrayUnion(playerDoc.id),\n        players: arrayUnion(playerSummary) \n      });\n\n      // 2. NEW: Update Linked Chat (Add player to chat)\n      // Find the chat associated with this roster\n      const chatsRef = collection(db, \"chats\");\n      const chatQ = query(chatsRef, where(\"rosterId\", \"==\", rosterId));\n      const chatSnapshot = await getDocs(chatQ);\n\n      if (!chatSnapshot.empty) {\n        const chatDoc = chatSnapshot.docs[0];\n        await updateDoc(chatDoc.ref, {\n          participants: arrayUnion(playerDoc.id),\n          visibleTo: arrayUnion(playerDoc.id), // Make it visible immediately\n          participantDetails: arrayUnion(playerSummary)\n        });\n      }\n\n      return true;\n\n    } catch (error) {\n      console.error(\"Error adding player:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const removePlayerFromRoster = async (rosterId, playerSummary) => {\n    if (!isManager()) return false;\n    \n    try {\n      // 1. Update Roster\n      const rosterRef = doc(db, \"rosters\", rosterId);\n      await updateDoc(rosterRef, {\n        playerIDs: arrayRemove(playerSummary.uid),\n        players: arrayRemove(playerSummary)\n      });\n\n      // 2. NEW: Update Linked Chat (Remove player from chat)\n      const chatsRef = collection(db, \"chats\");\n      const chatQ = query(chatsRef, where(\"rosterId\", \"==\", rosterId));\n      const chatSnapshot = await getDocs(chatQ);\n\n      if (!chatSnapshot.empty) {\n        const chatDoc = chatSnapshot.docs[0];\n        await updateDoc(chatDoc.ref, {\n          participants: arrayRemove(playerSummary.uid),\n          visibleTo: arrayRemove(playerSummary.uid),\n          participantDetails: arrayRemove(playerSummary)\n        });\n      }\n\n      return true;\n    } catch (error) {\n      console.error(\"Error removing player:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  // ... (fetchUserRosters, createEvent, fetchEvents, deleteEvent, fetchAllUserEvents REMAIN UNCHANGED) ...\n  \n  const fetchUserRosters = async (uid) => {\n    try {\n      const rostersRef = collection(db, \"rosters\");\n      const q = query(rostersRef, where(\"playerIDs\", \"array-contains\", uid));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n    } catch (error) {\n      console.error(\"Error fetching user rosters:\", error);\n      return [];\n    }\n  };\n\n  const createEvent = async (rosterId, eventData) => {\n    try {\n      await addDoc(collection(db, \"rosters\", rosterId, \"events\"), {\n        ...eventData,\n        createdAt: new Date()\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating event:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const fetchEvents = async (rosterId) => {\n    try {\n      const eventsRef = collection(db, \"rosters\", rosterId, \"events\");\n      const q = query(eventsRef, orderBy(\"dateTime\", \"asc\"));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n    } catch (error) {\n      console.error(\"Error fetching events:\", error);\n      return [];\n    }\n  };\n\n  const deleteEvent = async (rosterId, eventId) => {\n    if (!isManager()) return false;\n    try {\n      await deleteDoc(doc(db, \"rosters\", rosterId, \"events\", eventId));\n      return true;\n    } catch (error) {\n      console.error(\"Error deleting event:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const fetchAllUserEvents = async (uid) => {\n    try {\n      const rosters = await fetchUserRosters(uid);\n      let allEvents = [];\n      for (const roster of rosters) {\n        const eventsRef = collection(db, \"rosters\", roster.id, \"events\");\n        const q = query(eventsRef); \n        const querySnapshot = await getDocs(q);\n        const rosterEvents = querySnapshot.docs.map(doc => ({\n          id: doc.id,\n          rosterName: roster.name, \n          ...doc.data()\n        }));\n        allEvents = [...allEvents, ...rosterEvents];\n      }\n      allEvents.sort((a, b) => new Date(a.dateTime) - new Date(b.dateTime));\n      return allEvents;\n    } catch (error) {\n      console.error(\"Error fetching all events:\", error);\n      return [];\n    }\n  };\n\n  // --- UPDATED: Flexible Chat Functions ---\n\n  // 1. Create a new chat (DM or Group)\n  // NEW: Initializes visibleTo\n  const createChat = async (participantEmails, chatName = \"\") => {\n    try {\n      const usersRef = collection(db, \"users\");\n      \n      const participants = [];\n      const participantIds = [loggedInUser.uid];\n\n      participants.push({\n        uid: loggedInUser.uid,\n        name: loggedInUser.playerName,\n        email: loggedInUser.email\n      });\n\n      for (const email of participantEmails) {\n        if (email === loggedInUser.email) continue; \n\n        const q = query(usersRef, where(\"email\", \"==\", email));\n        const snapshot = await getDocs(q);\n        \n        if (!snapshot.empty) {\n          const userDoc = snapshot.docs[0];\n          const userData = userDoc.data();\n          \n          participantIds.push(userDoc.id);\n          participants.push({\n            uid: userDoc.id,\n            name: userData.playerName || \"Unknown\",\n            email: userData.email\n          });\n        }\n      }\n\n      if (participantIds.length < 2) {\n        alert(\"Could not find any valid users to chat with.\");\n        return false;\n      }\n\n      await addDoc(collection(db, \"chats\"), {\n        type: participantIds.length > 2 ? 'group' : 'dm',\n        name: chatName || (participants.length === 2 ? participants[1].name : \"Group Chat\"),\n        participants: participantIds,\n        visibleTo: participantIds, // NEW: All participants see it initially\n        participantDetails: participants,\n        createdAt: serverTimestamp(),\n        lastMessage: \"Chat created\",\n        lastMessageTime: serverTimestamp()\n      });\n\n      return true;\n\n    } catch (error) {\n      console.error(\"Error creating chat:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  // 2. Send a message\n  // NEW: Updates visibleTo for \"Resurrection\"\n  const sendMessage = async (chatId, text, currentParticipants) => {\n    try {\n      await addDoc(collection(db, \"chats\", chatId, \"messages\"), {\n        text: text,\n        senderId: loggedInUser.uid,\n        senderName: loggedInUser.playerName,\n        createdAt: serverTimestamp()\n      });\n\n      // Update parent chat doc\n      const chatRef = doc(db, \"chats\", chatId);\n      await updateDoc(chatRef, {\n        lastMessage: text,\n        lastMessageTime: serverTimestamp(),\n        // NEW: Resurrection Logic\n        // Set visibleTo back to the full participants list so it reappears for everyone\n        visibleTo: currentParticipants \n      });\n\n      return true;\n    } catch (error) {\n      console.error(\"Error sending message:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  // 3. Fetch chats for the current user\n  // NEW: Queries 'visibleTo' instead of 'participants'\n  const fetchUserChats = async (uid) => {\n    try {\n      const chatsRef = collection(db, \"chats\");\n      // NEW: Only fetch chats where I am in the 'visibleTo' array\n      const q = query(chatsRef, where(\"visibleTo\", \"array-contains\", uid), orderBy(\"lastMessageTime\", \"desc\"));\n      \n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error(\"Error fetching chats:\", error);\n      return [];\n    }\n  };\n\n  // NEW: Hide Chat Function\n  const hideChat = async (chatId, currentVisibleTo, chatType) => {\n    // Rule: Cannot hide/delete roster chats\n    if (chatType === 'roster') {\n      alert(\"Team Roster chats cannot be deleted.\");\n      return false;\n    }\n\n    try {\n      // Calculate the new visibility list (remove myself)\n      const newVisibleTo = currentVisibleTo.filter(uid => uid !== loggedInUser.uid);\n\n      if (newVisibleTo.length === 0) {\n        // If NO ONE can see it anymore, delete the chat document entirely (Cleanup)\n        await deleteDoc(doc(db, \"chats\", chatId));\n        console.log(\"Chat deleted permanently (no visible participants).\");\n      } else {\n        // Otherwise, just update the document to hide it for me\n        const chatRef = doc(db, \"chats\", chatId);\n        await updateDoc(chatRef, {\n          visibleTo: newVisibleTo\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Error hiding chat:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n\n  const value = {\n    loggedInUser,\n    soccerDetails,\n    isLoading,\n    needsReauth,\n    setNeedsReauth,\n    signIn,\n    signUp,\n    signOutUser,\n    updateProfile,\n    reauthenticate,\n    updateSoccerDetails,\n    isManager,\n    createRoster,\n    fetchRosters,\n    deleteRoster,\n    addPlayerToRoster,\n    removePlayerFromRoster,\n    fetchUserRosters,\n    createEvent,\n    fetchEvents,\n    deleteEvent,\n    fetchAllUserEvents,\n    createChat,\n    sendMessage,\n    fetchUserChats,\n    // NEW: Export hideChat\n    hideChat\n  };\n\n  return (\n    <AuthContext.Provider value={value}>\n      {children}\n    </AuthContext.Provider>\n  );\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}