{"ast":null,"code":"import _objectSpread from\"/Users/dbroxton/Documents/Projects/soccer-management-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import React,{createContext,useContext,useState,useEffect}from'react';import{collection,addDoc,setDoc,updateDoc,deleteDoc,doc,query,where,orderBy,onSnapshot,serverTimestamp,increment}from\"firebase/firestore\";import{db}from\"../firebase\";import{useAuth}from'./AuthContext';import{jsx as _jsx}from\"react/jsx-runtime\";const ChatContext=/*#__PURE__*/createContext();export const useChat=()=>{return useContext(ChatContext);};export const ChatProvider=_ref=>{let{children}=_ref;const{loggedInUser}=useAuth();const[myChats,setMyChats]=useState([]);// 1. GLOBAL LISTENER: Fetch chats for the logged-in user\nuseEffect(()=>{if(!loggedInUser){setMyChats([]);return;}const chatsRef=collection(db,\"chats\");const q=query(chatsRef,where(\"visibleTo\",\"array-contains\",loggedInUser.uid),orderBy(\"lastMessageTime\",\"desc\"));const unsubscribe=onSnapshot(q,snapshot=>{const chats=snapshot.docs.map(doc=>_objectSpread({id:doc.id},doc.data()));setMyChats(chats);},error=>{console.error(\"Error listening to chat list:\",error);});return()=>unsubscribe();},[loggedInUser]);// 2. MARK READ\nconst markChatAsRead=async chatId=>{if(!loggedInUser)return;try{const chatRef=doc(db,\"chats\",chatId);await updateDoc(chatRef,{[\"unreadCounts.\".concat(loggedInUser.uid)]:0});}catch(error){// Fallback for older documents without the field\ntry{const chatRef=doc(db,\"chats\",chatId);await setDoc(chatRef,{unreadCounts:{[loggedInUser.uid]:0}},{merge:true});}catch(e){console.error(\"Error marking read:\",e);}}};// 3. CREATE CHAT\nconst createChat=async function(participantEmails){let chatName=arguments.length>1&&arguments[1]!==undefined?arguments[1]:\"\";try{const usersRef=collection(db,\"users\");const participants=[];const participantIds=[loggedInUser.uid];// Add self\nparticipants.push({uid:loggedInUser.uid,name:loggedInUser.playerName,email:loggedInUser.email,photoURL:loggedInUser.photoURL||\"\"});// Resolve other emails to Users\nfor(const email of participantEmails){if(email===loggedInUser.email)continue;const q=query(usersRef,where(\"email\",\"==\",email));const querySnapshot=await import(\"firebase/firestore\").then(mod=>mod.getDocs(q));if(!querySnapshot.empty){const userDoc=querySnapshot.docs[0];const userData=userDoc.data();participantIds.push(userDoc.id);participants.push({uid:userDoc.id,name:userData.playerName||\"Unknown\",email:userData.email,photoURL:userData.photoURL||\"\"});}}if(participantIds.length<2){alert(\"Could not find any valid users to chat with.\");return false;}// Check for existing 1:1 or exact group match\n// (Note: We are doing a client-side check on the 'myChats' we already loaded)\nconst existingChat=myChats.find(c=>{if(c.participants.length!==participantIds.length)return false;return participantIds.every(id=>c.participants.includes(id));});if(existingChat){const chatRef=doc(db,\"chats\",existingChat.id);if(!existingChat.visibleTo.includes(loggedInUser.uid)){await updateDoc(chatRef,{visibleTo:arrayUnion(loggedInUser.uid)});}return _objectSpread({id:existingChat.id,participants:existingChat.participants,name:existingChat.name},existingChat);}// Create New\nconst initialUnread={};participantIds.forEach(uid=>initialUnread[uid]=0);const docRef=await addDoc(collection(db,\"chats\"),{type:participantIds.length>2?'group':'dm',name:chatName||(participants.length===2?participants[1].name:\"Group Chat\"),participants:participantIds,visibleTo:participantIds,participantDetails:participants,unreadCounts:initialUnread,createdAt:serverTimestamp(),lastMessage:\"Chat created\",lastMessageTime:new Date()});return{id:docRef.id,participants:participantIds,participantDetails:participants};}catch(error){console.error(\"Error creating chat:\",error);alert(\"Error: \"+error.message);return false;}};// 4. SEND MESSAGE\nconst sendMessage=async function(chatId,text,currentParticipants){let imageUrl=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;try{await addDoc(collection(db,\"chats\",chatId,\"messages\"),{text:text,imageUrl:imageUrl,senderId:loggedInUser.uid,senderName:loggedInUser.playerName,createdAt:serverTimestamp()});const chatRef=doc(db,\"chats\",chatId);let summary=text;if(imageUrl){summary=text?\"\\uD83D\\uDCF7 \".concat(text):\"ðŸ“· Sent an image\";}const visibleToUpdate=currentParticipants||[loggedInUser.uid];const updatePayload={lastMessage:summary,lastMessageTime:new Date(),visibleTo:visibleToUpdate};const unreadUpdates={};if(currentParticipants){currentParticipants.forEach(uid=>{if(uid!==loggedInUser.uid){unreadUpdates[\"unreadCounts.\".concat(uid)]=increment(1);}});}await updateDoc(chatRef,_objectSpread(_objectSpread({},updatePayload),unreadUpdates));return true;}catch(error){console.error(\"Error sending message:\",error);alert(\"Error: \"+error.message);return false;}};// 5. ADMIN / UTILS\nconst hideChat=async(chatId,currentVisibleTo,chatType)=>{if(chatType==='roster'){alert(\"Team Roster chats cannot be deleted.\");return false;}try{const newVisibleTo=currentVisibleTo.filter(uid=>uid!==loggedInUser.uid);if(newVisibleTo.length===0){await deleteDoc(doc(db,\"chats\",chatId));}else{const chatRef=doc(db,\"chats\",chatId);await updateDoc(chatRef,{visibleTo:newVisibleTo});}return true;}catch(error){console.error(\"Error hiding chat:\",error);return false;}};const renameChat=async(chatId,newName)=>{try{const chatRef=doc(db,\"chats\",chatId);await updateDoc(chatRef,{name:newName});return true;}catch(error){console.error(\"Error renaming chat:\",error);return false;}};// Need this for arrayUnion in createChat\nconst{arrayUnion}=require(\"firebase/firestore\");const value={myChats,createChat,sendMessage,hideChat,renameChat,markChatAsRead};return/*#__PURE__*/_jsx(ChatContext.Provider,{value:value,children:children});};","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","collection","addDoc","setDoc","updateDoc","deleteDoc","doc","query","where","orderBy","onSnapshot","serverTimestamp","increment","db","useAuth","jsx","_jsx","ChatContext","useChat","ChatProvider","_ref","children","loggedInUser","myChats","setMyChats","chatsRef","q","uid","unsubscribe","snapshot","chats","docs","map","_objectSpread","id","data","error","console","markChatAsRead","chatId","chatRef","concat","unreadCounts","merge","e","createChat","participantEmails","chatName","arguments","length","undefined","usersRef","participants","participantIds","push","name","playerName","email","photoURL","querySnapshot","then","mod","getDocs","empty","userDoc","userData","alert","existingChat","find","c","every","includes","visibleTo","arrayUnion","initialUnread","forEach","docRef","type","participantDetails","createdAt","lastMessage","lastMessageTime","Date","message","sendMessage","text","currentParticipants","imageUrl","senderId","senderName","summary","visibleToUpdate","updatePayload","unreadUpdates","hideChat","currentVisibleTo","chatType","newVisibleTo","filter","renameChat","newName","require","value","Provider"],"sources":["/Users/dbroxton/Documents/Projects/soccer-management-app/src/context/ChatContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect } from 'react';\nimport { \n  collection, addDoc, setDoc, updateDoc, deleteDoc, doc, \n  query, where, orderBy, onSnapshot, serverTimestamp, increment \n} from \"firebase/firestore\";\nimport { db } from \"../firebase\"; \nimport { useAuth } from './AuthContext';\n\nconst ChatContext = createContext();\n\nexport const useChat = () => {\n  return useContext(ChatContext);\n};\n\nexport const ChatProvider = ({ children }) => {\n  const { loggedInUser } = useAuth();\n  const [myChats, setMyChats] = useState([]);\n\n  // 1. GLOBAL LISTENER: Fetch chats for the logged-in user\n  useEffect(() => {\n    if (!loggedInUser) {\n      setMyChats([]);\n      return;\n    }\n\n    const chatsRef = collection(db, \"chats\");\n    const q = query(\n      chatsRef, \n      where(\"visibleTo\", \"array-contains\", loggedInUser.uid), \n      orderBy(\"lastMessageTime\", \"desc\")\n    );\n\n    const unsubscribe = onSnapshot(q, (snapshot) => {\n      const chats = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setMyChats(chats);\n    }, (error) => {\n      console.error(\"Error listening to chat list:\", error);\n    });\n\n    return () => unsubscribe();\n  }, [loggedInUser]);\n\n  // 2. MARK READ\n  const markChatAsRead = async (chatId) => {\n    if (!loggedInUser) return;\n    try {\n      const chatRef = doc(db, \"chats\", chatId);\n      await updateDoc(chatRef, {\n        [`unreadCounts.${loggedInUser.uid}`]: 0\n      });\n    } catch (error) {\n      // Fallback for older documents without the field\n      try {\n        const chatRef = doc(db, \"chats\", chatId);\n        await setDoc(chatRef, {\n          unreadCounts: { [loggedInUser.uid]: 0 }\n        }, { merge: true });\n      } catch (e) {\n        console.error(\"Error marking read:\", e);\n      }\n    }\n  };\n\n  // 3. CREATE CHAT\n  const createChat = async (participantEmails, chatName = \"\") => {\n    try {\n      const usersRef = collection(db, \"users\");\n      const participants = [];\n      const participantIds = [loggedInUser.uid];\n\n      // Add self\n      participants.push({\n        uid: loggedInUser.uid,\n        name: loggedInUser.playerName,\n        email: loggedInUser.email,\n        photoURL: loggedInUser.photoURL || \"\" \n      });\n\n      // Resolve other emails to Users\n      for (const email of participantEmails) {\n        if (email === loggedInUser.email) continue; \n        const q = query(usersRef, where(\"email\", \"==\", email));\n        const querySnapshot = await import(\"firebase/firestore\").then(mod => mod.getDocs(q));\n        \n        if (!querySnapshot.empty) {\n          const userDoc = querySnapshot.docs[0];\n          const userData = userDoc.data();\n          participantIds.push(userDoc.id);\n          participants.push({\n            uid: userDoc.id,\n            name: userData.playerName || \"Unknown\",\n            email: userData.email,\n            photoURL: userData.photoURL || \"\" \n          });\n        }\n      }\n\n      if (participantIds.length < 2) {\n        alert(\"Could not find any valid users to chat with.\");\n        return false;\n      }\n\n      // Check for existing 1:1 or exact group match\n      // (Note: We are doing a client-side check on the 'myChats' we already loaded)\n      const existingChat = myChats.find(c => {\n        if (c.participants.length !== participantIds.length) return false;\n        return participantIds.every(id => c.participants.includes(id));\n      });\n\n      if (existingChat) {\n        const chatRef = doc(db, \"chats\", existingChat.id);\n        if (!existingChat.visibleTo.includes(loggedInUser.uid)) {\n           await updateDoc(chatRef, {\n             visibleTo: arrayUnion(loggedInUser.uid)\n           });\n        }\n        return { \n          id: existingChat.id, \n          participants: existingChat.participants,\n          name: existingChat.name, \n          ...existingChat\n        };\n      }\n\n      // Create New\n      const initialUnread = {};\n      participantIds.forEach(uid => initialUnread[uid] = 0);\n\n      const docRef = await addDoc(collection(db, \"chats\"), {\n        type: participantIds.length > 2 ? 'group' : 'dm',\n        name: chatName || (participants.length === 2 ? participants[1].name : \"Group Chat\"),\n        participants: participantIds,\n        visibleTo: participantIds,\n        participantDetails: participants,\n        unreadCounts: initialUnread,\n        createdAt: serverTimestamp(),\n        lastMessage: \"Chat created\",\n        lastMessageTime: new Date() \n      });\n      \n      return { id: docRef.id, participants: participantIds, participantDetails: participants }; \n\n    } catch (error) {\n      console.error(\"Error creating chat:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  // 4. SEND MESSAGE\n  const sendMessage = async (chatId, text, currentParticipants, imageUrl = null) => {\n    try {\n      await addDoc(collection(db, \"chats\", chatId, \"messages\"), {\n        text: text,\n        imageUrl: imageUrl,\n        senderId: loggedInUser.uid,\n        senderName: loggedInUser.playerName,\n        createdAt: serverTimestamp()\n      });\n\n      const chatRef = doc(db, \"chats\", chatId);\n      let summary = text;\n      if (imageUrl) {\n        summary = text ? `ðŸ“· ${text}` : \"ðŸ“· Sent an image\";\n      }\n\n      const visibleToUpdate = currentParticipants || [loggedInUser.uid];\n      const updatePayload = {\n        lastMessage: summary,\n        lastMessageTime: new Date(),\n        visibleTo: visibleToUpdate\n      };\n\n      const unreadUpdates = {};\n      if (currentParticipants) {\n        currentParticipants.forEach(uid => {\n          if (uid !== loggedInUser.uid) {\n            unreadUpdates[`unreadCounts.${uid}`] = increment(1);\n          }\n        });\n      }\n\n      await updateDoc(chatRef, { ...updatePayload, ...unreadUpdates });\n      return true;\n    } catch (error) {\n      console.error(\"Error sending message:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  // 5. ADMIN / UTILS\n  const hideChat = async (chatId, currentVisibleTo, chatType) => {\n    if (chatType === 'roster') {\n      alert(\"Team Roster chats cannot be deleted.\");\n      return false;\n    }\n    try {\n      const newVisibleTo = currentVisibleTo.filter(uid => uid !== loggedInUser.uid);\n      if (newVisibleTo.length === 0) {\n        await deleteDoc(doc(db, \"chats\", chatId));\n      } else {\n        const chatRef = doc(db, \"chats\", chatId);\n        await updateDoc(chatRef, { visibleTo: newVisibleTo });\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Error hiding chat:\", error);\n      return false;\n    }\n  };\n\n  const renameChat = async (chatId, newName) => {\n    try {\n      const chatRef = doc(db, \"chats\", chatId);\n      await updateDoc(chatRef, { name: newName });\n      return true;\n    } catch (error) {\n      console.error(\"Error renaming chat:\", error);\n      return false;\n    }\n  };\n\n  // Need this for arrayUnion in createChat\n  const { arrayUnion } = require(\"firebase/firestore\"); \n\n  const value = {\n    myChats,\n    createChat,\n    sendMessage,\n    hideChat,\n    renameChat,\n    markChatAsRead\n  };\n\n  return (\n    <ChatContext.Provider value={value}>\n      {children}\n    </ChatContext.Provider>\n  );\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}