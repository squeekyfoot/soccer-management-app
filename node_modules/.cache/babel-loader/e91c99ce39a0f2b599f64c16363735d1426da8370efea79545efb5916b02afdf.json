{"ast":null,"code":"var _jsxFileName = \"/Users/dbroxton/Documents/Projects/soccer-management-app/src/context/AuthContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport { onAuthStateChanged, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, updateEmail, updateProfile as firebaseUpdateProfile, EmailAuthProvider, reauthenticateWithCredential, deleteUser } from \"firebase/auth\";\nimport { doc, getDoc, setDoc, updateDoc, collection, addDoc, getDocs, deleteDoc, query, where, arrayUnion, arrayRemove, orderBy, serverTimestamp, increment, onSnapshot } from \"firebase/firestore\";\nimport { ref, uploadBytes, getDownloadURL, deleteObject } from \"firebase/storage\";\nimport { auth, db, storage } from \"../firebase\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AuthContext = /*#__PURE__*/createContext();\nexport const useAuth = () => {\n  _s();\n  return useContext(AuthContext);\n};\n_s(useAuth, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const AuthProvider = ({\n  children\n}) => {\n  _s2();\n  const [loggedInUser, setLoggedInUser] = useState(null);\n  const [soccerDetails, setSoccerDetails] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [needsReauth, setNeedsReauth] = useState(false);\n\n  // Global Chat State (for unread badges)\n  const [myChats, setMyChats] = useState([]);\n  useEffect(() => {\n    const unsubscribe = onAuthStateChanged(auth, async user => {\n      if (user) {\n        const userDocRef = doc(db, \"users\", user.uid);\n        const userDoc = await getDoc(userDocRef);\n        const soccerDocRef = doc(db, \"users\", user.uid, \"sportsDetails\", \"soccer\");\n        const soccerDoc = await getDoc(soccerDocRef);\n        if (userDoc.exists()) {\n          setLoggedInUser(userDoc.data());\n        } else {\n          setLoggedInUser(null);\n        }\n        if (soccerDoc.exists()) {\n          setSoccerDetails(soccerDoc.data());\n        } else {\n          setSoccerDetails(null);\n        }\n      } else {\n        setLoggedInUser(null);\n        setSoccerDetails(null);\n        setMyChats([]);\n      }\n      setIsLoading(false);\n    });\n    return () => unsubscribe();\n  }, []);\n\n  // Global Listener for Chats (Handles Unread Counts)\n  useEffect(() => {\n    if (!loggedInUser) {\n      setMyChats([]);\n      return;\n    }\n    const chatsRef = collection(db, \"chats\");\n    const q = query(chatsRef, where(\"visibleTo\", \"array-contains\", loggedInUser.uid), orderBy(\"lastMessageTime\", \"desc\"));\n    const unsubscribe = onSnapshot(q, snapshot => {\n      const chats = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setMyChats(chats);\n    }, error => {\n      console.error(\"Error listening to chat list:\", error);\n    });\n    return () => unsubscribe();\n  }, [loggedInUser]);\n\n  // Mark Chat as Read\n  const markChatAsRead = async chatId => {\n    if (!loggedInUser) return;\n    try {\n      const chatRef = doc(db, \"chats\", chatId);\n      await setDoc(chatRef, {\n        unreadCounts: {\n          [loggedInUser.uid]: 0\n        }\n      }, {\n        merge: true\n      });\n    } catch (error) {\n      console.error(\"Error marking chat as read:\", error);\n    }\n  };\n  const signIn = async (email, password) => {\n    setIsLoading(true);\n    try {\n      await signInWithEmailAndPassword(auth, email, password);\n    } catch (error) {\n      console.error(\"Error signing in:\", error);\n      alert(\"Error: \" + error.message);\n    }\n    setIsLoading(false);\n  };\n  const signUp = async formData => {\n    if (formData.password.length < 6) {\n      alert(\"Password must be at least 6 characters long.\");\n      return;\n    }\n\n    // FIX: Declare userCredential here so it is visible in the catch block\n    let userCredential;\n    try {\n      userCredential = await createUserWithEmailAndPassword(auth, formData.email, formData.password);\n      const user = userCredential.user;\n      const userProfileData = {\n        uid: user.uid,\n        playerName: formData.playerName,\n        email: formData.email,\n        phone: formData.phone,\n        address: formData.address,\n        notificationPreference: formData.notificationPreference,\n        comments: formData.comments,\n        role: 'player',\n        photoURL: \"\"\n      };\n      await setDoc(doc(db, \"users\", user.uid), userProfileData);\n      setLoggedInUser(userProfileData);\n    } catch (error) {\n      console.error(\"Error signing up:\", error);\n      alert(\"Error: \" + error.message);\n\n      // Cleanup: If Firestore write failed, delete the Auth user so they can try again.\n      if (userCredential && userCredential.user) {\n        try {\n          await deleteUser(userCredential.user);\n          console.log(\"Cleaned up orphaned auth user.\");\n        } catch (cleanupError) {\n          console.error(\"Failed to cleanup user:\", cleanupError);\n        }\n      }\n    }\n  };\n  const signOutUser = async () => {\n    try {\n      await signOut(auth);\n      setLoggedInUser(null);\n      setSoccerDetails(null);\n    } catch (error) {\n      console.error(\"Error signing out:\", error);\n      alert(\"Error: \" + error.message);\n    }\n  };\n  const uploadProfileImage = async (file, uid) => {\n    if (!file) return null;\n    try {\n      const storageRef = ref(storage, `users/${uid}/profile.jpg`);\n      await uploadBytes(storageRef, file);\n      return await getDownloadURL(storageRef);\n    } catch (error) {\n      console.error(\"Error uploading profile image:\", error);\n      throw error;\n    }\n  };\n  const deleteProfileImage = async uid => {\n    try {\n      const storageRef = ref(storage, `users/${uid}/profile.jpg`);\n      await deleteObject(storageRef);\n    } catch (error) {\n      console.warn(\"Error deleting image (might not exist):\", error);\n    }\n  };\n  const updateProfile = async (profileData, newImageFile = null, removeImage = false) => {\n    if (!loggedInUser) return;\n    if (profileData.email !== loggedInUser.email) {\n      try {\n        await updateEmail(auth.currentUser, profileData.email);\n      } catch (error) {\n        if (error.code === 'auth/requires-recent-login') {\n          setNeedsReauth(true);\n        } else {\n          alert(\"Error: \" + error.message);\n        }\n        return;\n      }\n    }\n    try {\n      let photoURL = loggedInUser.photoURL;\n      if (removeImage) {\n        await deleteProfileImage(loggedInUser.uid);\n        photoURL = \"\";\n      } else if (newImageFile) {\n        photoURL = await uploadProfileImage(newImageFile, loggedInUser.uid);\n      }\n      const dataToUpdate = {\n        playerName: profileData.playerName,\n        phone: profileData.phone,\n        address: profileData.address,\n        notificationPreference: profileData.notificationPreference,\n        comments: profileData.comments,\n        email: profileData.email,\n        photoURL: photoURL || \"\"\n      };\n      const userDocRef = doc(db, \"users\", loggedInUser.uid);\n      await updateDoc(userDocRef, dataToUpdate);\n      await firebaseUpdateProfile(auth.currentUser, {\n        displayName: profileData.playerName,\n        photoURL: photoURL\n      });\n      setLoggedInUser(prevUser => ({\n        ...prevUser,\n        ...dataToUpdate\n      }));\n\n      // Propagate Updates to Chats\n      const chatsRef = collection(db, \"chats\");\n      const q = query(chatsRef, where(\"participants\", \"array-contains\", loggedInUser.uid));\n      const querySnapshot = await getDocs(q);\n      const batchPromises = querySnapshot.docs.map(async chatDoc => {\n        const chatData = chatDoc.data();\n        if (chatData.participantDetails) {\n          const updatedDetails = chatData.participantDetails.map(p => {\n            if (p.uid === loggedInUser.uid) {\n              return {\n                ...p,\n                name: profileData.playerName,\n                email: profileData.email,\n                photoURL: photoURL || \"\"\n              };\n            }\n            return p;\n          });\n          await updateDoc(chatDoc.ref, {\n            participantDetails: updatedDetails\n          });\n        }\n      });\n      await Promise.all(batchPromises);\n      alert(\"Profile successfully updated!\");\n      return true;\n    } catch (error) {\n      alert(\"Error saving profile: \" + error.message);\n      return false;\n    }\n  };\n  const reauthenticate = async (password, newEmail) => {\n    if (!auth.currentUser || !password) return;\n    try {\n      const credential = EmailAuthProvider.credential(auth.currentUser.email, password);\n      await reauthenticateWithCredential(auth.currentUser, credential);\n      await updateEmail(auth.currentUser, newEmail);\n      const userDocRef = doc(db, \"users\", loggedInUser.uid);\n      await updateDoc(userDocRef, {\n        email: newEmail\n      });\n      setLoggedInUser(prevUser => ({\n        ...prevUser,\n        email: newEmail\n      }));\n      alert(\"Email successfully updated!\");\n      setNeedsReauth(false);\n      return true;\n    } catch (error) {\n      alert(\"Error: Incorrect password or another error occurred. \" + error.message);\n      return false;\n    }\n  };\n  const updateSoccerDetails = async soccerData => {\n    if (!loggedInUser) return;\n    try {\n      const soccerDataToSave = {\n        ...soccerData,\n        currentRosters: soccerData.currentRosters.split(',').map(item => item.trim()),\n        rosterJerseysOwned: soccerData.rosterJerseysOwned.split(',').map(item => item.trim()),\n        playerNumber: Number(soccerData.playerNumber) || 0\n      };\n      const soccerDocRef = doc(db, \"users\", loggedInUser.uid, \"sportsDetails\", \"soccer\");\n      await setDoc(soccerDocRef, soccerDataToSave);\n      setSoccerDetails(soccerDataToSave);\n      alert(\"Soccer info saved!\");\n      return true;\n    } catch (error) {\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const isManager = () => {\n    return loggedInUser && loggedInUser.role === 'manager';\n  };\n  const createRoster = async (rosterName, season, maxCapacity) => {\n    if (!isManager()) {\n      alert(\"Only managers can create rosters.\");\n      return false;\n    }\n    try {\n      const rosterRef = await addDoc(collection(db, \"rosters\"), {\n        name: rosterName,\n        season: season,\n        maxCapacity: Number(maxCapacity),\n        createdBy: loggedInUser.uid,\n        createdAt: new Date(),\n        playerIDs: [],\n        players: []\n      });\n      await addDoc(collection(db, \"chats\"), {\n        type: 'roster',\n        rosterId: rosterRef.id,\n        name: `${rosterName} (${season})`,\n        participants: [loggedInUser.uid],\n        visibleTo: [loggedInUser.uid],\n        participantDetails: [{\n          uid: loggedInUser.uid,\n          name: loggedInUser.playerName,\n          email: loggedInUser.email,\n          photoURL: loggedInUser.photoURL || \"\"\n        }],\n        unreadCounts: {\n          [loggedInUser.uid]: 0\n        },\n        createdAt: serverTimestamp(),\n        lastMessage: \"Team chat created\",\n        lastMessageTime: serverTimestamp()\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating roster:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const fetchRosters = async () => {\n    try {\n      const querySnapshot = await getDocs(collection(db, \"rosters\"));\n      return querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error(\"Error fetching rosters:\", error);\n      return [];\n    }\n  };\n  const deleteRoster = async rosterId => {\n    if (!isManager()) return false;\n    try {\n      await deleteDoc(doc(db, \"rosters\", rosterId));\n      return true;\n    } catch (error) {\n      console.error(\"Error deleting roster:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const addPlayerToRoster = async (rosterId, playerEmail) => {\n    if (!isManager()) return false;\n    try {\n      const usersRef = collection(db, \"users\");\n      const q = query(usersRef, where(\"email\", \"==\", playerEmail));\n      const querySnapshot = await getDocs(q);\n      if (querySnapshot.empty) {\n        alert(\"No player found with that email address.\");\n        return false;\n      }\n      const playerDoc = querySnapshot.docs[0];\n      const playerData = playerDoc.data();\n      const playerSummary = {\n        uid: playerDoc.id,\n        playerName: playerData.playerName || \"Unknown\",\n        email: playerData.email,\n        photoURL: playerData.photoURL || \"\"\n      };\n      const rosterRef = doc(db, \"rosters\", rosterId);\n      await updateDoc(rosterRef, {\n        playerIDs: arrayUnion(playerDoc.id),\n        players: arrayUnion(playerSummary)\n      });\n      const chatsRef = collection(db, \"chats\");\n      const chatQ = query(chatsRef, where(\"rosterId\", \"==\", rosterId));\n      const chatSnapshot = await getDocs(chatQ);\n      if (!chatSnapshot.empty) {\n        const chatDoc = chatSnapshot.docs[0];\n        await setDoc(chatDoc.ref, {\n          participants: arrayUnion(playerDoc.id),\n          visibleTo: arrayUnion(playerDoc.id),\n          participantDetails: arrayUnion(playerSummary),\n          unreadCounts: {\n            [playerDoc.id]: 0\n          }\n        }, {\n          merge: true\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Error adding player:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const removePlayerFromRoster = async (rosterId, playerSummary) => {\n    if (!isManager()) return false;\n    try {\n      const rosterRef = doc(db, \"rosters\", rosterId);\n      await updateDoc(rosterRef, {\n        playerIDs: arrayRemove(playerSummary.uid),\n        players: arrayRemove(playerSummary)\n      });\n      const chatsRef = collection(db, \"chats\");\n      const chatQ = query(chatsRef, where(\"rosterId\", \"==\", rosterId));\n      const chatSnapshot = await getDocs(chatQ);\n      if (!chatSnapshot.empty) {\n        const chatDoc = chatSnapshot.docs[0];\n        await updateDoc(chatDoc.ref, {\n          participants: arrayRemove(playerSummary.uid),\n          visibleTo: arrayRemove(playerSummary.uid),\n          participantDetails: arrayRemove(playerSummary)\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Error removing player:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const fetchUserRosters = async uid => {\n    try {\n      const rostersRef = collection(db, \"rosters\");\n      const q = query(rostersRef, where(\"playerIDs\", \"array-contains\", uid));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error(\"Error fetching user rosters:\", error);\n      return [];\n    }\n  };\n  const createEvent = async (rosterId, eventData) => {\n    try {\n      await addDoc(collection(db, \"rosters\", rosterId, \"events\"), {\n        ...eventData,\n        createdAt: new Date()\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating event:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const fetchEvents = async rosterId => {\n    try {\n      const eventsRef = collection(db, \"rosters\", rosterId, \"events\");\n      const q = query(eventsRef, orderBy(\"dateTime\", \"asc\"));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error(\"Error fetching events:\", error);\n      return [];\n    }\n  };\n  const deleteEvent = async (rosterId, eventId) => {\n    if (!isManager()) return false;\n    try {\n      await deleteDoc(doc(db, \"rosters\", rosterId, \"events\", eventId));\n      return true;\n    } catch (error) {\n      console.error(\"Error deleting event:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const fetchAllUserEvents = async uid => {\n    try {\n      const rosters = await fetchUserRosters(uid);\n      let allEvents = [];\n      for (const roster of rosters) {\n        const eventsRef = collection(db, \"rosters\", roster.id, \"events\");\n        const q = query(eventsRef);\n        const querySnapshot = await getDocs(q);\n        const rosterEvents = querySnapshot.docs.map(doc => ({\n          id: doc.id,\n          rosterName: roster.name,\n          ...doc.data()\n        }));\n        allEvents = [...allEvents, ...rosterEvents];\n      }\n      allEvents.sort((a, b) => new Date(a.dateTime) - new Date(b.dateTime));\n      return allEvents;\n    } catch (error) {\n      console.error(\"Error fetching all events:\", error);\n      return [];\n    }\n  };\n  const uploadImage = async (file, path) => {\n    if (!file) return null;\n    try {\n      const storageRef = ref(storage, `${path}/${Date.now()}_${file.name}`);\n      const snapshot = await uploadBytes(storageRef, file);\n      const downloadURL = await getDownloadURL(snapshot.ref);\n      return downloadURL;\n    } catch (error) {\n      console.error(\"Error uploading image:\", error);\n      throw error;\n    }\n  };\n  const createChat = async (participantEmails, chatName = \"\") => {\n    try {\n      const usersRef = collection(db, \"users\");\n      const participants = [];\n      const participantIds = [loggedInUser.uid];\n      participants.push({\n        uid: loggedInUser.uid,\n        name: loggedInUser.playerName,\n        email: loggedInUser.email,\n        photoURL: loggedInUser.photoURL || \"\"\n      });\n      for (const email of participantEmails) {\n        if (email === loggedInUser.email) continue;\n        const q = query(usersRef, where(\"email\", \"==\", email));\n        const snapshot = await getDocs(q);\n        if (!snapshot.empty) {\n          const userDoc = snapshot.docs[0];\n          const userData = userDoc.data();\n          participantIds.push(userDoc.id);\n          participants.push({\n            uid: userDoc.id,\n            name: userData.playerName || \"Unknown\",\n            email: userData.email,\n            photoURL: userData.photoURL || \"\"\n          });\n        }\n      }\n      if (participantIds.length < 2) {\n        alert(\"Could not find any valid users to chat with.\");\n        return false;\n      }\n      const chatsRef = collection(db, \"chats\");\n      const q = query(chatsRef, where(\"participants\", \"array-contains\", loggedInUser.uid));\n      const chatSnapshot = await getDocs(q);\n      const existingChat = chatSnapshot.docs.find(doc => {\n        const data = doc.data();\n        if (data.participants.length !== participantIds.length) return false;\n        return participantIds.every(id => data.participants.includes(id));\n      });\n      if (existingChat) {\n        const existingData = existingChat.data();\n        const chatRef = doc(db, \"chats\", existingChat.id);\n        if (!existingData.visibleTo.includes(loggedInUser.uid)) {\n          await updateDoc(chatRef, {\n            visibleTo: arrayUnion(loggedInUser.uid)\n          });\n        }\n        return {\n          id: existingChat.id,\n          participants: existingData.participants,\n          name: existingData.name,\n          ...existingData\n        };\n      }\n\n      // Initialize unread counts\n      const initialUnread = {};\n      participantIds.forEach(uid => initialUnread[uid] = 0);\n      const docRef = await addDoc(collection(db, \"chats\"), {\n        type: participantIds.length > 2 ? 'group' : 'dm',\n        name: chatName || (participants.length === 2 ? participants[1].name : \"Group Chat\"),\n        participants: participantIds,\n        visibleTo: participantIds,\n        participantDetails: participants,\n        unreadCounts: initialUnread,\n        createdAt: serverTimestamp(),\n        lastMessage: \"Chat created\",\n        lastMessageTime: new Date()\n      });\n      return {\n        id: docRef.id,\n        participants: participantIds,\n        participantDetails: participants\n      };\n    } catch (error) {\n      console.error(\"Error creating chat:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const sendMessage = async (chatId, text, currentParticipants, imageUrl = null) => {\n    try {\n      await addDoc(collection(db, \"chats\", chatId, \"messages\"), {\n        text: text,\n        imageUrl: imageUrl,\n        senderId: loggedInUser.uid,\n        senderName: loggedInUser.playerName,\n        createdAt: serverTimestamp()\n      });\n      const chatRef = doc(db, \"chats\", chatId);\n      let summary = text;\n      if (imageUrl) {\n        summary = text ? `ðŸ“· ${text}` : \"ðŸ“· Sent an image\";\n      }\n      const visibleToUpdate = currentParticipants || [loggedInUser.uid];\n      const updatePayload = {\n        lastMessage: summary,\n        lastMessageTime: new Date(),\n        visibleTo: visibleToUpdate\n      };\n      const unreadUpdates = {};\n      if (currentParticipants) {\n        currentParticipants.forEach(uid => {\n          if (uid !== loggedInUser.uid) {\n            unreadUpdates[`unreadCounts.${uid}`] = increment(1);\n          }\n        });\n      }\n      await setDoc(chatRef, {\n        ...updatePayload,\n        ...unreadUpdates\n      }, {\n        merge: true\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error sending message:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const fetchUserChats = async uid => {\n    try {\n      const chatsRef = collection(db, \"chats\");\n      const q = query(chatsRef, where(\"visibleTo\", \"array-contains\", uid), orderBy(\"lastMessageTime\", \"desc\"));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error(\"Error fetching chats:\", error);\n      return [];\n    }\n  };\n  const hideChat = async (chatId, currentVisibleTo, chatType) => {\n    if (chatType === 'roster') {\n      alert(\"Team Roster chats cannot be deleted.\");\n      return false;\n    }\n    try {\n      const newVisibleTo = currentVisibleTo.filter(uid => uid !== loggedInUser.uid);\n      if (newVisibleTo.length === 0) {\n        await deleteDoc(doc(db, \"chats\", chatId));\n      } else {\n        const chatRef = doc(db, \"chats\", chatId);\n        await updateDoc(chatRef, {\n          visibleTo: newVisibleTo\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Error hiding chat:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const renameChat = async (chatId, newName) => {\n    try {\n      const chatRef = doc(db, \"chats\", chatId);\n      await updateDoc(chatRef, {\n        name: newName\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error renaming chat:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const createGroup = async groupData => {\n    try {\n      await addDoc(collection(db, \"groups\"), {\n        ...groupData,\n        createdBy: loggedInUser.uid,\n        createdAt: serverTimestamp(),\n        members: [loggedInUser.uid],\n        memberDetails: [{\n          uid: loggedInUser.uid,\n          name: loggedInUser.playerName,\n          email: loggedInUser.email,\n          photoURL: loggedInUser.photoURL || \"\",\n          role: 'owner'\n        }]\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating group:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n  const fetchUserGroups = async uid => {\n    try {\n      const groupsRef = collection(db, \"groups\");\n      const q = query(groupsRef, where(\"members\", \"array-contains\", uid));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error(\"Error fetching groups:\", error);\n      return [];\n    }\n  };\n  const createGroupPost = async (groupId, text, imageUrl = null) => {\n    try {\n      await addDoc(collection(db, \"groups\", groupId, \"posts\"), {\n        text: text,\n        imageUrl: imageUrl,\n        authorId: loggedInUser.uid,\n        authorName: loggedInUser.playerName,\n        authorPhoto: loggedInUser.photoURL || \"\",\n        createdAt: serverTimestamp(),\n        replies: []\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating post:\", error);\n      return false;\n    }\n  };\n  const addGroupMembers = async (groupId, emails) => {\n    try {\n      const groupRef = doc(db, \"groups\", groupId);\n      const groupSnap = await getDoc(groupRef);\n      if (!groupSnap.exists()) return false;\n      const groupData = groupSnap.data();\n      const myMemberDetails = groupData.memberDetails.find(m => m.uid === loggedInUser.uid);\n      if (!myMemberDetails || myMemberDetails.role !== 'owner' && myMemberDetails.role !== 'admin') {\n        alert(\"Only Owners and Admins can add members.\");\n        return false;\n      }\n      const usersRef = collection(db, \"users\");\n      const newMembers = [];\n      const newMemberIds = [];\n      for (const email of emails) {\n        const q = query(usersRef, where(\"email\", \"==\", email));\n        const snapshot = await getDocs(q);\n        if (!snapshot.empty) {\n          const userDoc = snapshot.docs[0];\n          const userData = userDoc.data();\n          if (!groupData.members.includes(userDoc.id)) {\n            newMemberIds.push(userDoc.id);\n            newMembers.push({\n              uid: userDoc.id,\n              name: userData.playerName || \"Unknown\",\n              email: userData.email,\n              photoURL: userData.photoURL || \"\",\n              role: 'member'\n            });\n          }\n        }\n      }\n      if (newMemberIds.length === 0) {\n        return true;\n      }\n      await updateDoc(groupRef, {\n        members: arrayUnion(...newMemberIds),\n        memberDetails: arrayUnion(...newMembers)\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error adding group members:\", error);\n      alert(\"Error adding members: \" + error.message);\n      return false;\n    }\n  };\n  const updateGroupMemberRole = async (groupId, memberUid, newRole, currentMemberDetails) => {\n    try {\n      const groupRef = doc(db, \"groups\", groupId);\n      const updatedMemberDetails = currentMemberDetails.map(member => {\n        if (member.uid === memberUid) {\n          return {\n            ...member,\n            role: newRole\n          };\n        }\n        return member;\n      });\n      await updateDoc(groupRef, {\n        memberDetails: updatedMemberDetails\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error updating role:\", error);\n      alert(\"Error updating role: \" + error.message);\n      return false;\n    }\n  };\n  const transferGroupOwnership = async (groupId, newOwnerUid, currentMemberDetails) => {\n    try {\n      const groupRef = doc(db, \"groups\", groupId);\n      const updatedMemberDetails = currentMemberDetails.map(member => {\n        if (member.uid === loggedInUser.uid) {\n          return {\n            ...member,\n            role: 'admin'\n          };\n        }\n        if (member.uid === newOwnerUid) {\n          return {\n            ...member,\n            role: 'owner'\n          };\n        }\n        return member;\n      });\n      await updateDoc(groupRef, {\n        memberDetails: updatedMemberDetails\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error transferring ownership:\", error);\n      alert(\"Error transferring ownership: \" + error.message);\n      return false;\n    }\n  };\n  const removeGroupMember = async (groupId, memberUid, currentMemberDetails, currentMembers) => {\n    try {\n      const groupRef = doc(db, \"groups\", groupId);\n      const updatedMemberDetails = currentMemberDetails.filter(m => m.uid !== memberUid);\n      const updatedMembers = currentMembers.filter(uid => uid !== memberUid);\n      await updateDoc(groupRef, {\n        memberDetails: updatedMemberDetails,\n        members: updatedMembers\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error removing member:\", error);\n      alert(\"Error removing member: \" + error.message);\n      return false;\n    }\n  };\n  const value = {\n    loggedInUser,\n    soccerDetails,\n    isLoading,\n    needsReauth,\n    setNeedsReauth,\n    signIn,\n    signUp,\n    signOutUser,\n    updateProfile,\n    reauthenticate,\n    updateSoccerDetails,\n    isManager,\n    createRoster,\n    fetchRosters,\n    deleteRoster,\n    addPlayerToRoster,\n    removePlayerFromRoster,\n    fetchUserRosters,\n    createEvent,\n    fetchEvents,\n    deleteEvent,\n    fetchAllUserEvents,\n    createChat,\n    sendMessage,\n    fetchUserChats,\n    hideChat,\n    renameChat,\n    uploadImage,\n    createGroup,\n    fetchUserGroups,\n    createGroupPost,\n    addGroupMembers,\n    updateGroupMemberRole,\n    transferGroupOwnership,\n    removeGroupMember,\n    myChats,\n    markChatAsRead\n  };\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 947,\n    columnNumber: 5\n  }, this);\n};\n_s2(AuthProvider, \"0TolNCb/GHYc5XfyejDGlOeyLHY=\");\n_c = AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","onAuthStateChanged","signInWithEmailAndPassword","createUserWithEmailAndPassword","signOut","updateEmail","updateProfile","firebaseUpdateProfile","EmailAuthProvider","reauthenticateWithCredential","deleteUser","doc","getDoc","setDoc","updateDoc","collection","addDoc","getDocs","deleteDoc","query","where","arrayUnion","arrayRemove","orderBy","serverTimestamp","increment","onSnapshot","ref","uploadBytes","getDownloadURL","deleteObject","auth","db","storage","jsxDEV","_jsxDEV","AuthContext","useAuth","_s","AuthProvider","children","_s2","loggedInUser","setLoggedInUser","soccerDetails","setSoccerDetails","isLoading","setIsLoading","needsReauth","setNeedsReauth","myChats","setMyChats","unsubscribe","user","userDocRef","uid","userDoc","soccerDocRef","soccerDoc","exists","data","chatsRef","q","snapshot","chats","docs","map","id","error","console","markChatAsRead","chatId","chatRef","unreadCounts","merge","signIn","email","password","alert","message","signUp","formData","length","userCredential","userProfileData","playerName","phone","address","notificationPreference","comments","role","photoURL","log","cleanupError","signOutUser","uploadProfileImage","file","storageRef","deleteProfileImage","warn","profileData","newImageFile","removeImage","currentUser","code","dataToUpdate","displayName","prevUser","querySnapshot","batchPromises","chatDoc","chatData","participantDetails","updatedDetails","p","name","Promise","all","reauthenticate","newEmail","credential","updateSoccerDetails","soccerData","soccerDataToSave","currentRosters","split","item","trim","rosterJerseysOwned","playerNumber","Number","isManager","createRoster","rosterName","season","maxCapacity","rosterRef","createdBy","createdAt","Date","playerIDs","players","type","rosterId","participants","visibleTo","lastMessage","lastMessageTime","fetchRosters","deleteRoster","addPlayerToRoster","playerEmail","usersRef","empty","playerDoc","playerData","playerSummary","chatQ","chatSnapshot","removePlayerFromRoster","fetchUserRosters","rostersRef","createEvent","eventData","fetchEvents","eventsRef","deleteEvent","eventId","fetchAllUserEvents","rosters","allEvents","roster","rosterEvents","sort","a","b","dateTime","uploadImage","path","now","downloadURL","createChat","participantEmails","chatName","participantIds","push","userData","existingChat","find","every","includes","existingData","initialUnread","forEach","docRef","sendMessage","text","currentParticipants","imageUrl","senderId","senderName","summary","visibleToUpdate","updatePayload","unreadUpdates","fetchUserChats","hideChat","currentVisibleTo","chatType","newVisibleTo","filter","renameChat","newName","createGroup","groupData","members","memberDetails","fetchUserGroups","groupsRef","createGroupPost","groupId","authorId","authorName","authorPhoto","replies","addGroupMembers","emails","groupRef","groupSnap","myMemberDetails","m","newMembers","newMemberIds","updateGroupMemberRole","memberUid","newRole","currentMemberDetails","updatedMemberDetails","member","transferGroupOwnership","newOwnerUid","removeGroupMember","currentMembers","updatedMembers","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/dbroxton/Documents/Projects/soccer-management-app/src/context/AuthContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect } from 'react';\nimport {\n  onAuthStateChanged,\n  signInWithEmailAndPassword,\n  createUserWithEmailAndPassword,\n  signOut,\n  updateEmail,\n  updateProfile as firebaseUpdateProfile,\n  EmailAuthProvider,\n  reauthenticateWithCredential,\n  deleteUser\n} from \"firebase/auth\";\nimport { \n  doc, getDoc, setDoc, updateDoc, collection, addDoc, getDocs, deleteDoc, \n  query, where, arrayUnion, arrayRemove, orderBy, serverTimestamp, increment, onSnapshot \n} from \"firebase/firestore\";\nimport { ref, uploadBytes, getDownloadURL, deleteObject } from \"firebase/storage\";\nimport { auth, db, storage } from \"../firebase\"; \n\nconst AuthContext = createContext();\n\nexport const useAuth = () => {\n  return useContext(AuthContext);\n};\n\nexport const AuthProvider = ({ children }) => {\n  const [loggedInUser, setLoggedInUser] = useState(null);\n  const [soccerDetails, setSoccerDetails] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [needsReauth, setNeedsReauth] = useState(false);\n  \n  // Global Chat State (for unread badges)\n  const [myChats, setMyChats] = useState([]);\n\n  useEffect(() => {\n    const unsubscribe = onAuthStateChanged(auth, async (user) => {\n      if (user) {\n        const userDocRef = doc(db, \"users\", user.uid);\n        const userDoc = await getDoc(userDocRef);\n        const soccerDocRef = doc(db, \"users\", user.uid, \"sportsDetails\", \"soccer\");\n        const soccerDoc = await getDoc(soccerDocRef);\n\n        if (userDoc.exists()) {\n          setLoggedInUser(userDoc.data());\n        } else {\n          setLoggedInUser(null);\n        }\n\n        if (soccerDoc.exists()) {\n          setSoccerDetails(soccerDoc.data());\n        } else {\n          setSoccerDetails(null);\n        }\n      } else {\n        setLoggedInUser(null);\n        setSoccerDetails(null);\n        setMyChats([]); \n      }\n      setIsLoading(false);\n    });\n\n    return () => unsubscribe();\n  }, []); \n\n  // Global Listener for Chats (Handles Unread Counts)\n  useEffect(() => {\n    if (!loggedInUser) {\n      setMyChats([]);\n      return;\n    }\n\n    const chatsRef = collection(db, \"chats\");\n    const q = query(\n      chatsRef, \n      where(\"visibleTo\", \"array-contains\", loggedInUser.uid), \n      orderBy(\"lastMessageTime\", \"desc\")\n    );\n\n    const unsubscribe = onSnapshot(q, (snapshot) => {\n      const chats = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setMyChats(chats);\n    }, (error) => {\n      console.error(\"Error listening to chat list:\", error);\n    });\n\n    return () => unsubscribe();\n  }, [loggedInUser]);\n\n  // Mark Chat as Read\n  const markChatAsRead = async (chatId) => {\n    if (!loggedInUser) return;\n    try {\n      const chatRef = doc(db, \"chats\", chatId);\n      await setDoc(chatRef, {\n        unreadCounts: {\n          [loggedInUser.uid]: 0\n        }\n      }, { merge: true });\n    } catch (error) {\n      console.error(\"Error marking chat as read:\", error);\n    }\n  };\n\n  const signIn = async (email, password) => {\n    setIsLoading(true);\n    try {\n      await signInWithEmailAndPassword(auth, email, password);\n    } catch (error) {\n      console.error(\"Error signing in:\", error);\n      alert(\"Error: \" + error.message);\n    }\n    setIsLoading(false);\n  };\n\n  const signUp = async (formData) => {\n    if (formData.password.length < 6) {\n      alert(\"Password must be at least 6 characters long.\");\n      return;\n    }\n    \n    // FIX: Declare userCredential here so it is visible in the catch block\n    let userCredential;\n\n    try {\n      userCredential = await createUserWithEmailAndPassword(auth, formData.email, formData.password);\n      const user = userCredential.user;\n      \n      const userProfileData = {\n        uid: user.uid,\n        playerName: formData.playerName,\n        email: formData.email,\n        phone: formData.phone,\n        address: formData.address,\n        notificationPreference: formData.notificationPreference,\n        comments: formData.comments,\n        role: 'player', \n        photoURL: \"\"\n      };\n      \n      await setDoc(doc(db, \"users\", user.uid), userProfileData);\n      setLoggedInUser(userProfileData);\n\n    } catch (error) {\n      console.error(\"Error signing up:\", error);\n      alert(\"Error: \" + error.message);\n\n      // Cleanup: If Firestore write failed, delete the Auth user so they can try again.\n      if (userCredential && userCredential.user) {\n        try {\n          await deleteUser(userCredential.user);\n          console.log(\"Cleaned up orphaned auth user.\");\n        } catch (cleanupError) {\n          console.error(\"Failed to cleanup user:\", cleanupError);\n        }\n      }\n    }\n  };\n\n  const signOutUser = async () => {\n    try {\n      await signOut(auth);\n      setLoggedInUser(null);\n      setSoccerDetails(null);\n    } catch (error) {\n      console.error(\"Error signing out:\", error);\n      alert(\"Error: \" + error.message);\n    }\n  };\n\n  const uploadProfileImage = async (file, uid) => {\n    if (!file) return null;\n    try {\n      const storageRef = ref(storage, `users/${uid}/profile.jpg`);\n      await uploadBytes(storageRef, file);\n      return await getDownloadURL(storageRef);\n    } catch (error) {\n      console.error(\"Error uploading profile image:\", error);\n      throw error;\n    }\n  };\n\n  const deleteProfileImage = async (uid) => {\n    try {\n      const storageRef = ref(storage, `users/${uid}/profile.jpg`);\n      await deleteObject(storageRef);\n    } catch (error) {\n      console.warn(\"Error deleting image (might not exist):\", error);\n    }\n  };\n\n  const updateProfile = async (profileData, newImageFile = null, removeImage = false) => {\n    if (!loggedInUser) return;\n\n    if (profileData.email !== loggedInUser.email) {\n      try {\n        await updateEmail(auth.currentUser, profileData.email);\n      } catch (error) {\n        if (error.code === 'auth/requires-recent-login') {\n          setNeedsReauth(true); \n        } else {\n          alert(\"Error: \" + error.message);\n        }\n        return;\n      }\n    }\n\n    try {\n      let photoURL = loggedInUser.photoURL;\n\n      if (removeImage) {\n        await deleteProfileImage(loggedInUser.uid);\n        photoURL = \"\";\n      } else if (newImageFile) {\n        photoURL = await uploadProfileImage(newImageFile, loggedInUser.uid);\n      }\n\n      const dataToUpdate = {\n        playerName: profileData.playerName,\n        phone: profileData.phone,\n        address: profileData.address,\n        notificationPreference: profileData.notificationPreference,\n        comments: profileData.comments,\n        email: profileData.email,\n        photoURL: photoURL || \"\"\n      };\n      \n      const userDocRef = doc(db, \"users\", loggedInUser.uid);\n      await updateDoc(userDocRef, dataToUpdate);\n      \n      await firebaseUpdateProfile(auth.currentUser, {\n        displayName: profileData.playerName,\n        photoURL: photoURL\n      });\n      \n      setLoggedInUser(prevUser => ({\n        ...prevUser,\n        ...dataToUpdate\n      }));\n\n      // Propagate Updates to Chats\n      const chatsRef = collection(db, \"chats\");\n      const q = query(chatsRef, where(\"participants\", \"array-contains\", loggedInUser.uid));\n      const querySnapshot = await getDocs(q);\n\n      const batchPromises = querySnapshot.docs.map(async (chatDoc) => {\n        const chatData = chatDoc.data();\n        if (chatData.participantDetails) {\n          const updatedDetails = chatData.participantDetails.map(p => {\n            if (p.uid === loggedInUser.uid) {\n              return { \n                ...p, \n                name: profileData.playerName, \n                email: profileData.email,\n                photoURL: photoURL || \"\" \n              };\n            }\n            return p;\n          });\n          await updateDoc(chatDoc.ref, { participantDetails: updatedDetails });\n        }\n      });\n      \n      await Promise.all(batchPromises);\n      \n      alert(\"Profile successfully updated!\");\n      return true; \n    } catch (error) {\n      alert(\"Error saving profile: \" + error.message);\n      return false;\n    }\n  };\n\n  const reauthenticate = async (password, newEmail) => {\n    if (!auth.currentUser || !password) return;\n    try {\n      const credential = EmailAuthProvider.credential(auth.currentUser.email, password);\n      await reauthenticateWithCredential(auth.currentUser, credential);\n      await updateEmail(auth.currentUser, newEmail);\n      const userDocRef = doc(db, \"users\", loggedInUser.uid);\n      await updateDoc(userDocRef, { email: newEmail });\n\n      setLoggedInUser(prevUser => ({\n        ...prevUser,\n        email: newEmail\n      }));\n\n      alert(\"Email successfully updated!\");\n      setNeedsReauth(false); \n      return true; \n    } catch (error) {\n      alert(\"Error: Incorrect password or another error occurred. \" + error.message);\n      return false;\n    }\n  };\n\n  const updateSoccerDetails = async (soccerData) => {\n    if (!loggedInUser) return;\n    try {\n      const soccerDataToSave = {\n        ...soccerData,\n        currentRosters: soccerData.currentRosters.split(',').map(item => item.trim()),\n        rosterJerseysOwned: soccerData.rosterJerseysOwned.split(',').map(item => item.trim()),\n        playerNumber: Number(soccerData.playerNumber) || 0,\n      };\n      \n      const soccerDocRef = doc(db, \"users\", loggedInUser.uid, \"sportsDetails\", \"soccer\");\n      await setDoc(soccerDocRef, soccerDataToSave);\n      \n      setSoccerDetails(soccerDataToSave); \n      alert(\"Soccer info saved!\");\n      return true; \n\n    } catch (error) {\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const isManager = () => {\n    return loggedInUser && loggedInUser.role === 'manager';\n  };\n\n  const createRoster = async (rosterName, season, maxCapacity) => {\n    if (!isManager()) {\n      alert(\"Only managers can create rosters.\");\n      return false;\n    }\n    try {\n      const rosterRef = await addDoc(collection(db, \"rosters\"), {\n        name: rosterName,\n        season: season,\n        maxCapacity: Number(maxCapacity),\n        createdBy: loggedInUser.uid,\n        createdAt: new Date(),\n        playerIDs: [],\n        players: [] \n      });\n\n      await addDoc(collection(db, \"chats\"), {\n        type: 'roster', \n        rosterId: rosterRef.id,\n        name: `${rosterName} (${season})`,\n        participants: [loggedInUser.uid],\n        visibleTo: [loggedInUser.uid],\n        participantDetails: [{\n          uid: loggedInUser.uid,\n          name: loggedInUser.playerName,\n          email: loggedInUser.email,\n          photoURL: loggedInUser.photoURL || \"\"\n        }],\n        unreadCounts: { [loggedInUser.uid]: 0 },\n        createdAt: serverTimestamp(),\n        lastMessage: \"Team chat created\",\n        lastMessageTime: serverTimestamp()\n      });\n\n      return true;\n    } catch (error) {\n      console.error(\"Error creating roster:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const fetchRosters = async () => {\n    try {\n      const querySnapshot = await getDocs(collection(db, \"rosters\"));\n      return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n    } catch (error) {\n      console.error(\"Error fetching rosters:\", error);\n      return [];\n    }\n  };\n\n  const deleteRoster = async (rosterId) => {\n    if (!isManager()) return false;\n    try {\n      await deleteDoc(doc(db, \"rosters\", rosterId));\n      return true;\n    } catch (error) {\n      console.error(\"Error deleting roster:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const addPlayerToRoster = async (rosterId, playerEmail) => {\n    if (!isManager()) return false;\n    \n    try {\n      const usersRef = collection(db, \"users\");\n      const q = query(usersRef, where(\"email\", \"==\", playerEmail));\n      const querySnapshot = await getDocs(q);\n\n      if (querySnapshot.empty) {\n        alert(\"No player found with that email address.\");\n        return false;\n      }\n\n      const playerDoc = querySnapshot.docs[0];\n      const playerData = playerDoc.data();\n\n      const playerSummary = {\n        uid: playerDoc.id,\n        playerName: playerData.playerName || \"Unknown\",\n        email: playerData.email,\n        photoURL: playerData.photoURL || \"\"\n      };\n\n      const rosterRef = doc(db, \"rosters\", rosterId);\n      await updateDoc(rosterRef, {\n        playerIDs: arrayUnion(playerDoc.id),\n        players: arrayUnion(playerSummary) \n      });\n\n      const chatsRef = collection(db, \"chats\");\n      const chatQ = query(chatsRef, where(\"rosterId\", \"==\", rosterId));\n      const chatSnapshot = await getDocs(chatQ);\n\n      if (!chatSnapshot.empty) {\n        const chatDoc = chatSnapshot.docs[0];\n        await setDoc(chatDoc.ref, {\n          participants: arrayUnion(playerDoc.id),\n          visibleTo: arrayUnion(playerDoc.id),\n          participantDetails: arrayUnion(playerSummary),\n          unreadCounts: { [playerDoc.id]: 0 }\n        }, { merge: true });\n      }\n      return true;\n\n    } catch (error) {\n      console.error(\"Error adding player:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const removePlayerFromRoster = async (rosterId, playerSummary) => {\n    if (!isManager()) return false;\n    \n    try {\n      const rosterRef = doc(db, \"rosters\", rosterId);\n      await updateDoc(rosterRef, {\n        playerIDs: arrayRemove(playerSummary.uid),\n        players: arrayRemove(playerSummary)\n      });\n\n      const chatsRef = collection(db, \"chats\");\n      const chatQ = query(chatsRef, where(\"rosterId\", \"==\", rosterId));\n      const chatSnapshot = await getDocs(chatQ);\n\n      if (!chatSnapshot.empty) {\n        const chatDoc = chatSnapshot.docs[0];\n        await updateDoc(chatDoc.ref, {\n          participants: arrayRemove(playerSummary.uid),\n          visibleTo: arrayRemove(playerSummary.uid),\n          participantDetails: arrayRemove(playerSummary)\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Error removing player:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const fetchUserRosters = async (uid) => {\n    try {\n      const rostersRef = collection(db, \"rosters\");\n      const q = query(rostersRef, where(\"playerIDs\", \"array-contains\", uid));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n    } catch (error) {\n      console.error(\"Error fetching user rosters:\", error);\n      return [];\n    }\n  };\n\n  const createEvent = async (rosterId, eventData) => {\n    try {\n      await addDoc(collection(db, \"rosters\", rosterId, \"events\"), {\n        ...eventData,\n        createdAt: new Date()\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating event:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const fetchEvents = async (rosterId) => {\n    try {\n      const eventsRef = collection(db, \"rosters\", rosterId, \"events\");\n      const q = query(eventsRef, orderBy(\"dateTime\", \"asc\"));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n    } catch (error) {\n      console.error(\"Error fetching events:\", error);\n      return [];\n    }\n  };\n\n  const deleteEvent = async (rosterId, eventId) => {\n    if (!isManager()) return false;\n    try {\n      await deleteDoc(doc(db, \"rosters\", rosterId, \"events\", eventId));\n      return true;\n    } catch (error) {\n      console.error(\"Error deleting event:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const fetchAllUserEvents = async (uid) => {\n    try {\n      const rosters = await fetchUserRosters(uid);\n      let allEvents = [];\n      for (const roster of rosters) {\n        const eventsRef = collection(db, \"rosters\", roster.id, \"events\");\n        const q = query(eventsRef); \n        const querySnapshot = await getDocs(q);\n        \n        const rosterEvents = querySnapshot.docs.map(doc => ({\n          id: doc.id,\n          rosterName: roster.name, \n          ...doc.data()\n        }));\n        allEvents = [...allEvents, ...rosterEvents];\n      }\n      allEvents.sort((a, b) => new Date(a.dateTime) - new Date(b.dateTime));\n      return allEvents;\n    } catch (error) {\n      console.error(\"Error fetching all events:\", error);\n      return [];\n    }\n  };\n\n  const uploadImage = async (file, path) => {\n    if (!file) return null;\n    try {\n      const storageRef = ref(storage, `${path}/${Date.now()}_${file.name}`);\n      const snapshot = await uploadBytes(storageRef, file);\n      const downloadURL = await getDownloadURL(snapshot.ref);\n      return downloadURL;\n    } catch (error) {\n      console.error(\"Error uploading image:\", error);\n      throw error;\n    }\n  };\n\n  const createChat = async (participantEmails, chatName = \"\") => {\n    try {\n      const usersRef = collection(db, \"users\");\n      const participants = [];\n      const participantIds = [loggedInUser.uid];\n\n      participants.push({\n        uid: loggedInUser.uid,\n        name: loggedInUser.playerName,\n        email: loggedInUser.email,\n        photoURL: loggedInUser.photoURL || \"\" \n      });\n\n      for (const email of participantEmails) {\n        if (email === loggedInUser.email) continue; \n        const q = query(usersRef, where(\"email\", \"==\", email));\n        const snapshot = await getDocs(q);\n        if (!snapshot.empty) {\n          const userDoc = snapshot.docs[0];\n          const userData = userDoc.data();\n          participantIds.push(userDoc.id);\n          participants.push({\n            uid: userDoc.id,\n            name: userData.playerName || \"Unknown\",\n            email: userData.email,\n            photoURL: userData.photoURL || \"\" \n          });\n        }\n      }\n\n      if (participantIds.length < 2) {\n        alert(\"Could not find any valid users to chat with.\");\n        return false;\n      }\n\n      const chatsRef = collection(db, \"chats\");\n      const q = query(chatsRef, where(\"participants\", \"array-contains\", loggedInUser.uid));\n      const chatSnapshot = await getDocs(q);\n\n      const existingChat = chatSnapshot.docs.find(doc => {\n        const data = doc.data();\n        if (data.participants.length !== participantIds.length) return false;\n        return participantIds.every(id => data.participants.includes(id));\n      });\n\n      if (existingChat) {\n        const existingData = existingChat.data();\n        const chatRef = doc(db, \"chats\", existingChat.id);\n\n        if (!existingData.visibleTo.includes(loggedInUser.uid)) {\n           await updateDoc(chatRef, {\n             visibleTo: arrayUnion(loggedInUser.uid)\n           });\n        }\n\n        return { \n          id: existingChat.id, \n          participants: existingData.participants,\n          name: existingData.name, \n          ...existingData\n        };\n      }\n\n      // Initialize unread counts\n      const initialUnread = {};\n      participantIds.forEach(uid => initialUnread[uid] = 0);\n\n      const docRef = await addDoc(collection(db, \"chats\"), {\n        type: participantIds.length > 2 ? 'group' : 'dm',\n        name: chatName || (participants.length === 2 ? participants[1].name : \"Group Chat\"),\n        participants: participantIds,\n        visibleTo: participantIds,\n        participantDetails: participants,\n        unreadCounts: initialUnread,\n        createdAt: serverTimestamp(),\n        lastMessage: \"Chat created\",\n        lastMessageTime: new Date() \n      });\n      \n      return { id: docRef.id, participants: participantIds, participantDetails: participants }; \n\n    } catch (error) {\n      console.error(\"Error creating chat:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const sendMessage = async (chatId, text, currentParticipants, imageUrl = null) => {\n    try {\n      await addDoc(collection(db, \"chats\", chatId, \"messages\"), {\n        text: text,\n        imageUrl: imageUrl,\n        senderId: loggedInUser.uid,\n        senderName: loggedInUser.playerName,\n        createdAt: serverTimestamp()\n      });\n\n      const chatRef = doc(db, \"chats\", chatId);\n      let summary = text;\n      if (imageUrl) {\n        summary = text ? `ðŸ“· ${text}` : \"ðŸ“· Sent an image\";\n      }\n\n      const visibleToUpdate = currentParticipants || [loggedInUser.uid];\n\n      const updatePayload = {\n        lastMessage: summary,\n        lastMessageTime: new Date(),\n        visibleTo: visibleToUpdate\n      };\n\n      const unreadUpdates = {};\n      if (currentParticipants) {\n        currentParticipants.forEach(uid => {\n          if (uid !== loggedInUser.uid) {\n            unreadUpdates[`unreadCounts.${uid}`] = increment(1);\n          }\n        });\n      }\n\n      await setDoc(chatRef, { ...updatePayload, ...unreadUpdates }, { merge: true });\n\n      return true;\n    } catch (error) {\n      console.error(\"Error sending message:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const fetchUserChats = async (uid) => {\n    try {\n      const chatsRef = collection(db, \"chats\");\n      const q = query(chatsRef, where(\"visibleTo\", \"array-contains\", uid), orderBy(\"lastMessageTime\", \"desc\"));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error(\"Error fetching chats:\", error);\n      return [];\n    }\n  };\n\n  const hideChat = async (chatId, currentVisibleTo, chatType) => {\n    if (chatType === 'roster') {\n      alert(\"Team Roster chats cannot be deleted.\");\n      return false;\n    }\n    try {\n      const newVisibleTo = currentVisibleTo.filter(uid => uid !== loggedInUser.uid);\n      if (newVisibleTo.length === 0) {\n        await deleteDoc(doc(db, \"chats\", chatId));\n      } else {\n        const chatRef = doc(db, \"chats\", chatId);\n        await updateDoc(chatRef, {\n          visibleTo: newVisibleTo\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Error hiding chat:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const renameChat = async (chatId, newName) => {\n    try {\n      const chatRef = doc(db, \"chats\", chatId);\n      await updateDoc(chatRef, { name: newName });\n      return true;\n    } catch (error) {\n      console.error(\"Error renaming chat:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const createGroup = async (groupData) => {\n     try {\n      await addDoc(collection(db, \"groups\"), {\n        ...groupData,\n        createdBy: loggedInUser.uid,\n        createdAt: serverTimestamp(),\n        members: [loggedInUser.uid], \n        memberDetails: [{\n          uid: loggedInUser.uid,\n          name: loggedInUser.playerName,\n          email: loggedInUser.email,\n          photoURL: loggedInUser.photoURL || \"\",\n          role: 'owner' \n        }]\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating group:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  const fetchUserGroups = async (uid) => {\n    try {\n      const groupsRef = collection(db, \"groups\");\n      const q = query(groupsRef, where(\"members\", \"array-contains\", uid));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n    } catch (error) {\n      console.error(\"Error fetching groups:\", error);\n      return [];\n    }\n  };\n\n  const createGroupPost = async (groupId, text, imageUrl = null) => {\n     try {\n      await addDoc(collection(db, \"groups\", groupId, \"posts\"), {\n        text: text,\n        imageUrl: imageUrl,\n        authorId: loggedInUser.uid,\n        authorName: loggedInUser.playerName,\n        authorPhoto: loggedInUser.photoURL || \"\",\n        createdAt: serverTimestamp(),\n        replies: [] \n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error creating post:\", error);\n      return false;\n    }\n  };\n\n  const addGroupMembers = async (groupId, emails) => {\n    try {\n      const groupRef = doc(db, \"groups\", groupId);\n      const groupSnap = await getDoc(groupRef);\n      \n      if (!groupSnap.exists()) return false;\n      \n      const groupData = groupSnap.data();\n      const myMemberDetails = groupData.memberDetails.find(m => m.uid === loggedInUser.uid);\n      \n      if (!myMemberDetails || (myMemberDetails.role !== 'owner' && myMemberDetails.role !== 'admin')) {\n        alert(\"Only Owners and Admins can add members.\");\n        return false;\n      }\n\n      const usersRef = collection(db, \"users\");\n      const newMembers = [];\n      const newMemberIds = [];\n\n      for (const email of emails) {\n        const q = query(usersRef, where(\"email\", \"==\", email));\n        const snapshot = await getDocs(q);\n        \n        if (!snapshot.empty) {\n          const userDoc = snapshot.docs[0];\n          const userData = userDoc.data();\n          \n          if (!groupData.members.includes(userDoc.id)) {\n             newMemberIds.push(userDoc.id);\n             newMembers.push({\n               uid: userDoc.id,\n               name: userData.playerName || \"Unknown\",\n               email: userData.email,\n               photoURL: userData.photoURL || \"\",\n               role: 'member'\n             });\n          }\n        }\n      }\n\n      if (newMemberIds.length === 0) {\n        return true; \n      }\n\n      await updateDoc(groupRef, {\n        members: arrayUnion(...newMemberIds),\n        memberDetails: arrayUnion(...newMembers)\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error adding group members:\", error);\n      alert(\"Error adding members: \" + error.message);\n      return false;\n    }\n  };\n\n  const updateGroupMemberRole = async (groupId, memberUid, newRole, currentMemberDetails) => {\n    try {\n      const groupRef = doc(db, \"groups\", groupId);\n      const updatedMemberDetails = currentMemberDetails.map(member => {\n        if (member.uid === memberUid) {\n          return { ...member, role: newRole };\n        }\n        return member;\n      });\n      await updateDoc(groupRef, { memberDetails: updatedMemberDetails });\n      return true;\n    } catch (error) {\n      console.error(\"Error updating role:\", error);\n      alert(\"Error updating role: \" + error.message);\n      return false;\n    }\n  };\n\n  const transferGroupOwnership = async (groupId, newOwnerUid, currentMemberDetails) => {\n    try {\n      const groupRef = doc(db, \"groups\", groupId);\n      const updatedMemberDetails = currentMemberDetails.map(member => {\n        if (member.uid === loggedInUser.uid) {\n          return { ...member, role: 'admin' }; \n        }\n        if (member.uid === newOwnerUid) {\n          return { ...member, role: 'owner' };\n        }\n        return member;\n      });\n      await updateDoc(groupRef, { memberDetails: updatedMemberDetails });\n      return true;\n    } catch (error) {\n      console.error(\"Error transferring ownership:\", error);\n      alert(\"Error transferring ownership: \" + error.message);\n      return false;\n    }\n  };\n\n  const removeGroupMember = async (groupId, memberUid, currentMemberDetails, currentMembers) => {\n    try {\n      const groupRef = doc(db, \"groups\", groupId);\n      const updatedMemberDetails = currentMemberDetails.filter(m => m.uid !== memberUid);\n      const updatedMembers = currentMembers.filter(uid => uid !== memberUid);\n\n      await updateDoc(groupRef, {\n        memberDetails: updatedMemberDetails,\n        members: updatedMembers\n      });\n      \n      return true;\n    } catch (error) {\n      console.error(\"Error removing member:\", error);\n      alert(\"Error removing member: \" + error.message);\n      return false;\n    }\n  };\n\n  const value = {\n    loggedInUser,\n    soccerDetails,\n    isLoading,\n    needsReauth,\n    setNeedsReauth,\n    signIn,\n    signUp,\n    signOutUser,\n    updateProfile,\n    reauthenticate,\n    updateSoccerDetails,\n    isManager,\n    createRoster,\n    fetchRosters,\n    deleteRoster,\n    addPlayerToRoster,\n    removePlayerFromRoster,\n    fetchUserRosters,\n    createEvent,\n    fetchEvents,\n    deleteEvent,\n    fetchAllUserEvents,\n    createChat,\n    sendMessage,\n    fetchUserChats,\n    hideChat,\n    renameChat,\n    uploadImage,\n    createGroup,\n    fetchUserGroups,\n    createGroupPost,\n    addGroupMembers,\n    updateGroupMemberRole,\n    transferGroupOwnership,\n    removeGroupMember,\n    myChats, \n    markChatAsRead\n  };\n\n  return (\n    <AuthContext.Provider value={value}>\n      {children}\n    </AuthContext.Provider>\n  );\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}