{"ast":null,"code":"var _jsxFileName = \"/Users/dbroxton/Documents/Projects/soccer-management-app/src/context/ChatContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport { collection, addDoc, setDoc, updateDoc, deleteDoc, doc, query, where, orderBy, onSnapshot, serverTimestamp, increment, arrayRemove, getDoc } from \"firebase/firestore\";\nimport { db } from \"../firebase\";\nimport { useAuth } from './AuthContext';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ChatContext = /*#__PURE__*/createContext();\nexport const useChat = () => {\n  _s();\n  return useContext(ChatContext);\n};\n_s(useChat, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const ChatProvider = ({\n  children\n}) => {\n  _s2();\n  const {\n    loggedInUser\n  } = useAuth();\n  const [myChats, setMyChats] = useState([]);\n\n  // Need this for array operations\n  const {\n    arrayUnion\n  } = require(\"firebase/firestore\");\n\n  // 1. GLOBAL LISTENER\n  useEffect(() => {\n    if (!loggedInUser) {\n      setMyChats([]);\n      return;\n    }\n    const chatsRef = collection(db, \"chats\");\n    const q = query(chatsRef, where(\"visibleTo\", \"array-contains\", loggedInUser.uid), orderBy(\"lastMessageTime\", \"desc\"));\n    const unsubscribe = onSnapshot(q, snapshot => {\n      const chats = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setMyChats(chats);\n    }, error => {\n      console.error(\"Error listening to chat list:\", error);\n    });\n    return () => unsubscribe();\n  }, [loggedInUser]);\n\n  // 2. MARK READ\n  const markChatAsRead = async chatId => {\n    if (!loggedInUser) return;\n    try {\n      const chatRef = doc(db, \"chats\", chatId);\n      await updateDoc(chatRef, {\n        [`unreadCounts.${loggedInUser.uid}`]: 0\n      });\n    } catch (error) {\n      // Fallback/Safety\n      console.error(\"Error marking read:\", error);\n    }\n  };\n\n  // 3. CREATE CHAT\n  const createChat = async (participantEmails, chatName = \"\") => {\n    try {\n      const usersRef = collection(db, \"users\");\n      const participants = [];\n      const participantIds = [loggedInUser.uid];\n\n      // Add self\n      participants.push({\n        uid: loggedInUser.uid,\n        name: loggedInUser.playerName,\n        email: loggedInUser.email,\n        photoURL: loggedInUser.photoURL || \"\"\n      });\n\n      // Resolve other emails\n      for (const email of participantEmails) {\n        if (email === loggedInUser.email) continue;\n        const q = query(usersRef, where(\"email\", \"==\", email));\n        const querySnapshot = await import(\"firebase/firestore\").then(mod => mod.getDocs(q));\n        if (!querySnapshot.empty) {\n          const userDoc = querySnapshot.docs[0];\n          const userData = userDoc.data();\n          participantIds.push(userDoc.id);\n          participants.push({\n            uid: userDoc.id,\n            name: userData.playerName || \"Unknown\",\n            email: userData.email,\n            photoURL: userData.photoURL || \"\"\n          });\n        }\n      }\n      if (participantIds.length < 2) {\n        alert(\"Could not find any valid users to chat with.\");\n        return false;\n      }\n\n      // Check for existing\n      const existingChat = myChats.find(c => {\n        if (c.participants.length !== participantIds.length) return false;\n        return participantIds.every(id => c.participants.includes(id));\n      });\n      if (existingChat) {\n        const chatRef = doc(db, \"chats\", existingChat.id);\n        if (!existingChat.visibleTo.includes(loggedInUser.uid)) {\n          await updateDoc(chatRef, {\n            visibleTo: arrayUnion(loggedInUser.uid)\n          });\n        }\n        return {\n          id: existingChat.id,\n          participants: existingChat.participants,\n          name: existingChat.name,\n          ...existingChat\n        };\n      }\n\n      // Create New\n      const initialUnread = {};\n      participantIds.forEach(uid => initialUnread[uid] = 0);\n      const docRef = await addDoc(collection(db, \"chats\"), {\n        type: participantIds.length > 2 ? 'group' : 'dm',\n        name: chatName || (participants.length === 2 ? participants[1].name : \"Group Chat\"),\n        participants: participantIds,\n        visibleTo: participantIds,\n        participantDetails: participants,\n        unreadCounts: initialUnread,\n        createdAt: serverTimestamp(),\n        lastMessage: \"Chat created\",\n        lastMessageTime: new Date()\n      });\n      return {\n        id: docRef.id,\n        participants: participantIds,\n        participantDetails: participants\n      };\n    } catch (error) {\n      console.error(\"Error creating chat:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  // 4. SEND MESSAGE\n  const sendMessage = async (chatId, text, currentParticipants, imageUrl = null) => {\n    try {\n      await addDoc(collection(db, \"chats\", chatId, \"messages\"), {\n        text: text,\n        imageUrl: imageUrl,\n        senderId: loggedInUser.uid,\n        senderName: loggedInUser.playerName,\n        createdAt: serverTimestamp(),\n        type: 'text' // explicit type\n      });\n      const chatRef = doc(db, \"chats\", chatId);\n      let summary = text;\n      if (imageUrl) {\n        summary = text ? `ðŸ“· ${text}` : \"ðŸ“· Sent an image\";\n      }\n      const visibleToUpdate = currentParticipants || [loggedInUser.uid];\n      const updatePayload = {\n        lastMessage: summary,\n        lastMessageTime: new Date(),\n        visibleTo: visibleToUpdate\n      };\n      const unreadUpdates = {};\n      if (currentParticipants) {\n        currentParticipants.forEach(uid => {\n          if (uid !== loggedInUser.uid) {\n            unreadUpdates[`unreadCounts.${uid}`] = increment(1);\n          }\n        });\n      }\n      await updateDoc(chatRef, {\n        ...updatePayload,\n        ...unreadUpdates\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error sending message:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  // 5. UPDATE GROUP PHOTO (With System Message)\n  const updateGroupPhoto = async (chatId, photoURL) => {\n    try {\n      const chatRef = doc(db, \"chats\", chatId);\n\n      // 1. Update the chat document\n      await updateDoc(chatRef, {\n        photoURL: photoURL\n      });\n\n      // 2. Add System Message\n      const systemMsgText = `${loggedInUser.playerName} changed the group photo.`;\n      await addDoc(collection(db, \"chats\", chatId, \"messages\"), {\n        text: systemMsgText,\n        type: 'system',\n        createdAt: serverTimestamp()\n      });\n\n      // 3. Update Last Message summary\n      await updateDoc(chatRef, {\n        lastMessage: systemMsgText,\n        lastMessageTime: new Date()\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error updating group photo:\", error);\n      return false;\n    }\n  };\n\n  // 6. HIDE / LEAVE CHAT\n  // \"hide\" is for DMs (just hide from view)\n  // \"leave\" is for Groups (actually remove participant)\n\n  const hideChat = async (chatId, currentVisibleTo) => {\n    try {\n      const newVisibleTo = currentVisibleTo.filter(uid => uid !== loggedInUser.uid);\n      if (newVisibleTo.length === 0) {\n        // Last person hiding it? Just delete it? \n        // Or keep it in DB but visible to no one. Safety choice: keep it.\n        const chatRef = doc(db, \"chats\", chatId);\n        await updateDoc(chatRef, {\n          visibleTo: []\n        });\n      } else {\n        const chatRef = doc(db, \"chats\", chatId);\n        await updateDoc(chatRef, {\n          visibleTo: newVisibleTo\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Error hiding chat:\", error);\n      return false;\n    }\n  };\n  const leaveChat = async chatId => {\n    try {\n      const chatRef = doc(db, \"chats\", chatId);\n      const chatSnap = await getDoc(chatRef);\n      if (!chatSnap.exists()) return false;\n      const chatData = chatSnap.data();\n\n      // Remove self from participants and visibleTo\n      const updatedParticipants = chatData.participants.filter(uid => uid !== loggedInUser.uid);\n      const updatedVisibleTo = chatData.visibleTo.filter(uid => uid !== loggedInUser.uid);\n      const updatedDetails = chatData.participantDetails.filter(p => p.uid !== loggedInUser.uid);\n      await updateDoc(chatRef, {\n        participants: updatedParticipants,\n        visibleTo: updatedVisibleTo,\n        participantDetails: updatedDetails\n      });\n\n      // Add System Message indicating departure\n      const systemMsgText = `${loggedInUser.playerName} left the group.`;\n      await addDoc(collection(db, \"chats\", chatId, \"messages\"), {\n        text: systemMsgText,\n        type: 'system',\n        createdAt: serverTimestamp()\n      });\n\n      // Update last message logic if needed, but 'system' msg usually sufficient\n\n      return true;\n    } catch (error) {\n      console.error(\"Error leaving chat:\", error);\n      alert(\"Error leaving group: \" + error.message);\n      return false;\n    }\n  };\n  const renameChat = async (chatId, newName) => {\n    try {\n      const chatRef = doc(db, \"chats\", chatId);\n      await updateDoc(chatRef, {\n        name: newName\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error renaming chat:\", error);\n      return false;\n    }\n  };\n  const value = {\n    myChats,\n    createChat,\n    sendMessage,\n    updateGroupPhoto,\n    // NEW\n    leaveChat,\n    // NEW\n    hideChat,\n    renameChat,\n    markChatAsRead\n  };\n  return /*#__PURE__*/_jsxDEV(ChatContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 304,\n    columnNumber: 5\n  }, this);\n};\n_s2(ChatProvider, \"Zi8IvpC5T4q6G609hIr4YEPLgRE=\", false, function () {\n  return [useAuth];\n});\n_c = ChatProvider;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","collection","addDoc","setDoc","updateDoc","deleteDoc","doc","query","where","orderBy","onSnapshot","serverTimestamp","increment","arrayRemove","getDoc","db","useAuth","jsxDEV","_jsxDEV","ChatContext","useChat","_s","ChatProvider","children","_s2","loggedInUser","myChats","setMyChats","arrayUnion","require","chatsRef","q","uid","unsubscribe","snapshot","chats","docs","map","id","data","error","console","markChatAsRead","chatId","chatRef","createChat","participantEmails","chatName","usersRef","participants","participantIds","push","name","playerName","email","photoURL","querySnapshot","then","mod","getDocs","empty","userDoc","userData","length","alert","existingChat","find","c","every","includes","visibleTo","initialUnread","forEach","docRef","type","participantDetails","unreadCounts","createdAt","lastMessage","lastMessageTime","Date","message","sendMessage","text","currentParticipants","imageUrl","senderId","senderName","summary","visibleToUpdate","updatePayload","unreadUpdates","updateGroupPhoto","systemMsgText","hideChat","currentVisibleTo","newVisibleTo","filter","leaveChat","chatSnap","exists","chatData","updatedParticipants","updatedVisibleTo","updatedDetails","p","renameChat","newName","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/dbroxton/Documents/Projects/soccer-management-app/src/context/ChatContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect } from 'react';\nimport { \n  collection, addDoc, setDoc, updateDoc, deleteDoc, doc, \n  query, where, orderBy, onSnapshot, serverTimestamp, increment, arrayRemove, getDoc \n} from \"firebase/firestore\";\nimport { db } from \"../firebase\"; \nimport { useAuth } from './AuthContext';\n\nconst ChatContext = createContext();\n\nexport const useChat = () => {\n  return useContext(ChatContext);\n};\n\nexport const ChatProvider = ({ children }) => {\n  const { loggedInUser } = useAuth();\n  const [myChats, setMyChats] = useState([]);\n\n  // Need this for array operations\n  const { arrayUnion } = require(\"firebase/firestore\"); \n\n  // 1. GLOBAL LISTENER\n  useEffect(() => {\n    if (!loggedInUser) {\n      setMyChats([]);\n      return;\n    }\n\n    const chatsRef = collection(db, \"chats\");\n    const q = query(\n      chatsRef, \n      where(\"visibleTo\", \"array-contains\", loggedInUser.uid), \n      orderBy(\"lastMessageTime\", \"desc\")\n    );\n\n    const unsubscribe = onSnapshot(q, (snapshot) => {\n      const chats = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setMyChats(chats);\n    }, (error) => {\n      console.error(\"Error listening to chat list:\", error);\n    });\n\n    return () => unsubscribe();\n  }, [loggedInUser]);\n\n  // 2. MARK READ\n  const markChatAsRead = async (chatId) => {\n    if (!loggedInUser) return;\n    try {\n      const chatRef = doc(db, \"chats\", chatId);\n      await updateDoc(chatRef, {\n        [`unreadCounts.${loggedInUser.uid}`]: 0\n      });\n    } catch (error) {\n      // Fallback/Safety\n      console.error(\"Error marking read:\", error);\n    }\n  };\n\n  // 3. CREATE CHAT\n  const createChat = async (participantEmails, chatName = \"\") => {\n    try {\n      const usersRef = collection(db, \"users\");\n      const participants = [];\n      const participantIds = [loggedInUser.uid];\n\n      // Add self\n      participants.push({\n        uid: loggedInUser.uid,\n        name: loggedInUser.playerName,\n        email: loggedInUser.email,\n        photoURL: loggedInUser.photoURL || \"\" \n      });\n\n      // Resolve other emails\n      for (const email of participantEmails) {\n        if (email === loggedInUser.email) continue; \n        const q = query(usersRef, where(\"email\", \"==\", email));\n        const querySnapshot = await import(\"firebase/firestore\").then(mod => mod.getDocs(q));\n        \n        if (!querySnapshot.empty) {\n          const userDoc = querySnapshot.docs[0];\n          const userData = userDoc.data();\n          participantIds.push(userDoc.id);\n          participants.push({\n            uid: userDoc.id,\n            name: userData.playerName || \"Unknown\",\n            email: userData.email,\n            photoURL: userData.photoURL || \"\" \n          });\n        }\n      }\n\n      if (participantIds.length < 2) {\n        alert(\"Could not find any valid users to chat with.\");\n        return false;\n      }\n\n      // Check for existing\n      const existingChat = myChats.find(c => {\n        if (c.participants.length !== participantIds.length) return false;\n        return participantIds.every(id => c.participants.includes(id));\n      });\n\n      if (existingChat) {\n        const chatRef = doc(db, \"chats\", existingChat.id);\n        if (!existingChat.visibleTo.includes(loggedInUser.uid)) {\n           await updateDoc(chatRef, {\n             visibleTo: arrayUnion(loggedInUser.uid)\n           });\n        }\n        return { \n          id: existingChat.id, \n          participants: existingChat.participants,\n          name: existingChat.name, \n          ...existingChat\n        };\n      }\n\n      // Create New\n      const initialUnread = {};\n      participantIds.forEach(uid => initialUnread[uid] = 0);\n\n      const docRef = await addDoc(collection(db, \"chats\"), {\n        type: participantIds.length > 2 ? 'group' : 'dm',\n        name: chatName || (participants.length === 2 ? participants[1].name : \"Group Chat\"),\n        participants: participantIds,\n        visibleTo: participantIds,\n        participantDetails: participants,\n        unreadCounts: initialUnread,\n        createdAt: serverTimestamp(),\n        lastMessage: \"Chat created\",\n        lastMessageTime: new Date() \n      });\n      \n      return { id: docRef.id, participants: participantIds, participantDetails: participants }; \n\n    } catch (error) {\n      console.error(\"Error creating chat:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  // 4. SEND MESSAGE\n  const sendMessage = async (chatId, text, currentParticipants, imageUrl = null) => {\n    try {\n      await addDoc(collection(db, \"chats\", chatId, \"messages\"), {\n        text: text,\n        imageUrl: imageUrl,\n        senderId: loggedInUser.uid,\n        senderName: loggedInUser.playerName,\n        createdAt: serverTimestamp(),\n        type: 'text' // explicit type\n      });\n\n      const chatRef = doc(db, \"chats\", chatId);\n      let summary = text;\n      if (imageUrl) {\n        summary = text ? `ðŸ“· ${text}` : \"ðŸ“· Sent an image\";\n      }\n\n      const visibleToUpdate = currentParticipants || [loggedInUser.uid];\n      const updatePayload = {\n        lastMessage: summary,\n        lastMessageTime: new Date(),\n        visibleTo: visibleToUpdate\n      };\n\n      const unreadUpdates = {};\n      if (currentParticipants) {\n        currentParticipants.forEach(uid => {\n          if (uid !== loggedInUser.uid) {\n            unreadUpdates[`unreadCounts.${uid}`] = increment(1);\n          }\n        });\n      }\n\n      await updateDoc(chatRef, { ...updatePayload, ...unreadUpdates });\n      return true;\n    } catch (error) {\n      console.error(\"Error sending message:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  // 5. UPDATE GROUP PHOTO (With System Message)\n  const updateGroupPhoto = async (chatId, photoURL) => {\n    try {\n      const chatRef = doc(db, \"chats\", chatId);\n      \n      // 1. Update the chat document\n      await updateDoc(chatRef, { photoURL: photoURL });\n\n      // 2. Add System Message\n      const systemMsgText = `${loggedInUser.playerName} changed the group photo.`;\n      \n      await addDoc(collection(db, \"chats\", chatId, \"messages\"), {\n        text: systemMsgText,\n        type: 'system',\n        createdAt: serverTimestamp()\n      });\n\n      // 3. Update Last Message summary\n      await updateDoc(chatRef, {\n        lastMessage: systemMsgText,\n        lastMessageTime: new Date()\n      });\n\n      return true;\n    } catch (error) {\n      console.error(\"Error updating group photo:\", error);\n      return false;\n    }\n  };\n\n  // 6. HIDE / LEAVE CHAT\n  // \"hide\" is for DMs (just hide from view)\n  // \"leave\" is for Groups (actually remove participant)\n  \n  const hideChat = async (chatId, currentVisibleTo) => {\n    try {\n      const newVisibleTo = currentVisibleTo.filter(uid => uid !== loggedInUser.uid);\n      if (newVisibleTo.length === 0) {\n        // Last person hiding it? Just delete it? \n        // Or keep it in DB but visible to no one. Safety choice: keep it.\n        const chatRef = doc(db, \"chats\", chatId);\n        await updateDoc(chatRef, { visibleTo: [] });\n      } else {\n        const chatRef = doc(db, \"chats\", chatId);\n        await updateDoc(chatRef, { visibleTo: newVisibleTo });\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Error hiding chat:\", error);\n      return false;\n    }\n  };\n\n  const leaveChat = async (chatId) => {\n    try {\n      const chatRef = doc(db, \"chats\", chatId);\n      const chatSnap = await getDoc(chatRef);\n      if (!chatSnap.exists()) return false;\n\n      const chatData = chatSnap.data();\n      \n      // Remove self from participants and visibleTo\n      const updatedParticipants = chatData.participants.filter(uid => uid !== loggedInUser.uid);\n      const updatedVisibleTo = chatData.visibleTo.filter(uid => uid !== loggedInUser.uid);\n      const updatedDetails = chatData.participantDetails.filter(p => p.uid !== loggedInUser.uid);\n\n      await updateDoc(chatRef, {\n        participants: updatedParticipants,\n        visibleTo: updatedVisibleTo,\n        participantDetails: updatedDetails\n      });\n\n      // Add System Message indicating departure\n      const systemMsgText = `${loggedInUser.playerName} left the group.`;\n      await addDoc(collection(db, \"chats\", chatId, \"messages\"), {\n        text: systemMsgText,\n        type: 'system',\n        createdAt: serverTimestamp()\n      });\n      \n      // Update last message logic if needed, but 'system' msg usually sufficient\n      \n      return true;\n    } catch (error) {\n      console.error(\"Error leaving chat:\", error);\n      alert(\"Error leaving group: \" + error.message);\n      return false;\n    }\n  };\n\n  const renameChat = async (chatId, newName) => {\n    try {\n      const chatRef = doc(db, \"chats\", chatId);\n      await updateDoc(chatRef, { name: newName });\n      return true;\n    } catch (error) {\n      console.error(\"Error renaming chat:\", error);\n      return false;\n    }\n  };\n\n  const value = {\n    myChats,\n    createChat,\n    sendMessage,\n    updateGroupPhoto, // NEW\n    leaveChat,        // NEW\n    hideChat,\n    renameChat,\n    markChatAsRead\n  };\n\n  return (\n    <ChatContext.Provider value={value}>\n      {children}\n    </ChatContext.Provider>\n  );\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}