{"ast":null,"code":"var _jsxFileName = \"/Users/dbroxton/Documents/Projects/soccer-management-app/src/context/ChatContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect, useCallback } from 'react';\nimport { collection, addDoc, updateDoc, doc, query, where, orderBy, onSnapshot, serverTimestamp, increment, getDocs, getDoc, arrayUnion, deleteField } from \"firebase/firestore\";\nimport { db } from \"../config/firebase\";\nimport { useAuth } from './AuthContext';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ChatContext = /*#__PURE__*/createContext();\nexport const useChat = () => {\n  _s();\n  return useContext(ChatContext);\n};\n_s(useChat, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const ChatProvider = ({\n  children\n}) => {\n  _s2();\n  const {\n    loggedInUser\n  } = useAuth();\n  const [myChats, setMyChats] = useState([]);\n\n  // 1. GLOBAL LISTENER\n  useEffect(() => {\n    if (!loggedInUser) {\n      setMyChats([]);\n      return;\n    }\n    const chatsRef = collection(db, \"chats\");\n    const q = query(chatsRef, where(\"visibleTo\", \"array-contains\", loggedInUser.uid), orderBy(\"lastMessageTime\", \"desc\"));\n    const unsubscribe = onSnapshot(q, snapshot => {\n      const chats = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setMyChats(chats);\n    }, error => {\n      console.error(\"Error listening to chat list:\", error);\n    });\n    return () => unsubscribe();\n  }, [loggedInUser]);\n\n  // 2. MARK READ (Stabilized with useCallback)\n  const markChatAsRead = useCallback(async chatId => {\n    if (!loggedInUser) return;\n    try {\n      const chatRef = doc(db, \"chats\", chatId);\n      await updateDoc(chatRef, {\n        [`unreadCounts.${loggedInUser.uid}`]: 0\n      });\n    } catch (error) {\n      console.error(\"Error marking read:\", error);\n    }\n  }, [loggedInUser]);\n\n  // 3. CREATE CHAT\n  const createChat = async (participantEmails, chatName = \"\") => {\n    try {\n      const usersRef = collection(db, \"users\");\n      const participants = [];\n      const participantIds = [loggedInUser.uid];\n\n      // Add self\n      participants.push({\n        uid: loggedInUser.uid,\n        name: loggedInUser.playerName,\n        email: loggedInUser.email,\n        photoURL: loggedInUser.photoURL || \"\"\n      });\n\n      // Resolve other emails\n      for (const email of participantEmails) {\n        if (email === loggedInUser.email) continue;\n        const q = query(usersRef, where(\"email\", \"==\", email));\n        const querySnapshot = await getDocs(q);\n        if (!querySnapshot.empty) {\n          const userDoc = querySnapshot.docs[0];\n          const userData = userDoc.data();\n          participantIds.push(userDoc.id);\n          participants.push({\n            uid: userDoc.id,\n            name: userData.playerName || \"Unknown\",\n            email: userData.email,\n            photoURL: userData.photoURL || \"\"\n          });\n        }\n      }\n      if (participantIds.length < 2) {\n        alert(\"Could not find any valid users to chat with.\");\n        return false;\n      }\n\n      // Check for existing\n      const existingChat = myChats.find(c => {\n        if (c.participants.length !== participantIds.length) return false;\n        return participantIds.every(id => c.participants.includes(id));\n      });\n      if (existingChat) {\n        const chatRef = doc(db, \"chats\", existingChat.id);\n        if (!existingChat.visibleTo.includes(loggedInUser.uid)) {\n          await updateDoc(chatRef, {\n            visibleTo: arrayUnion(loggedInUser.uid)\n          });\n        }\n        return {\n          id: existingChat.id,\n          participants: existingChat.participants,\n          name: existingChat.name,\n          ...existingChat\n        };\n      }\n\n      // Create New\n      const initialUnread = {};\n      participantIds.forEach(uid => initialUnread[uid] = 0);\n      const docRef = await addDoc(collection(db, \"chats\"), {\n        type: participantIds.length > 2 ? 'group' : 'dm',\n        name: chatName || (participants.length === 2 ? participants[1].name : \"Group Chat\"),\n        participants: participantIds,\n        visibleTo: participantIds,\n        participantDetails: participants,\n        unreadCounts: initialUnread,\n        createdAt: serverTimestamp(),\n        lastMessage: \"Chat created\",\n        lastMessageTime: new Date()\n      });\n      return {\n        id: docRef.id,\n        participants: participantIds,\n        participantDetails: participants\n      };\n    } catch (error) {\n      console.error(\"Error creating chat:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  // 4. SEND MESSAGE\n  const sendMessage = async (chatId, text, currentParticipants, imageUrl = null) => {\n    try {\n      await addDoc(collection(db, \"chats\", chatId, \"messages\"), {\n        text: text,\n        imageUrl: imageUrl,\n        senderId: loggedInUser.uid,\n        senderName: loggedInUser.playerName,\n        createdAt: serverTimestamp(),\n        type: 'text'\n      });\n      const chatRef = doc(db, \"chats\", chatId);\n      let summary = text;\n      if (imageUrl) {\n        summary = text ? `ðŸ“· ${text}` : \"ðŸ“· Sent an image\";\n      }\n      const visibleToUpdate = currentParticipants || [loggedInUser.uid];\n      const updatePayload = {\n        lastMessage: summary,\n        lastMessageTime: new Date(),\n        visibleTo: visibleToUpdate\n      };\n      const unreadUpdates = {};\n      if (currentParticipants) {\n        currentParticipants.forEach(uid => {\n          if (uid !== loggedInUser.uid) {\n            unreadUpdates[`unreadCounts.${uid}`] = increment(1);\n          }\n        });\n      }\n      await updateDoc(chatRef, {\n        ...updatePayload,\n        ...unreadUpdates\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error sending message:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  // 5. UPDATE GROUP PHOTO\n  const updateGroupPhoto = async (chatId, photoURL) => {\n    try {\n      const chatRef = doc(db, \"chats\", chatId);\n      await updateDoc(chatRef, {\n        photoURL: photoURL\n      });\n      const systemMsgText = `${loggedInUser.playerName} changed the group photo.`;\n      await addDoc(collection(db, \"chats\", chatId, \"messages\"), {\n        text: systemMsgText,\n        type: 'system',\n        createdAt: serverTimestamp()\n      });\n      await updateDoc(chatRef, {\n        lastMessage: systemMsgText,\n        lastMessageTime: new Date()\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error updating group photo:\", error);\n      return false;\n    }\n  };\n\n  // 6. ADD PARTICIPANT\n  const addParticipant = async (chatId, newEmail, includeHistory) => {\n    try {\n      const usersRef = collection(db, \"users\");\n      const q = query(usersRef, where(\"email\", \"==\", newEmail));\n      const querySnapshot = await getDocs(q);\n      if (querySnapshot.empty) {\n        alert(\"User not found.\");\n        return false;\n      }\n      const userDoc = querySnapshot.docs[0];\n      const newUser = {\n        uid: userDoc.id,\n        name: userDoc.data().playerName || \"Unknown\",\n        email: userDoc.data().email,\n        photoURL: userDoc.data().photoURL || \"\"\n      };\n      const chatRef = doc(db, \"chats\", chatId);\n      const chatSnap = await getDoc(chatRef);\n      const chatData = chatSnap.data();\n      if (chatData.participants.includes(newUser.uid)) {\n        alert(\"User is already in the group.\");\n        return false;\n      }\n\n      // Basic Update\n      let updateData = {\n        participants: arrayUnion(newUser.uid),\n        visibleTo: arrayUnion(newUser.uid),\n        participantDetails: arrayUnion(newUser),\n        [`unreadCounts.${newUser.uid}`]: 0\n      };\n      if (!includeHistory) {\n        // Hide history -> Set timestamp\n        updateData[`hiddenHistory.${newUser.uid}`] = serverTimestamp();\n      } else {\n        // Show history -> EXPLICITLY DELETE any old restriction\n        updateData[`hiddenHistory.${newUser.uid}`] = deleteField();\n      }\n\n      // 1. Update Chat Doc\n      await updateDoc(chatRef, updateData);\n\n      // 2. Add System Message\n      const systemMsgText = `${loggedInUser.playerName} added ${newUser.name} to the group.`;\n      await addDoc(collection(db, \"chats\", chatId, \"messages\"), {\n        text: systemMsgText,\n        type: 'system',\n        createdAt: serverTimestamp()\n      });\n\n      // 3. Update Last Message\n      await updateDoc(chatRef, {\n        lastMessage: systemMsgText,\n        lastMessageTime: new Date()\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error adding participant:\", error);\n      alert(\"Error adding user: \" + error.message);\n      return false;\n    }\n  };\n\n  // 7. LEAVE/HIDE CHAT\n  const hideChat = async (chatId, currentVisibleTo) => {\n    try {\n      const newVisibleTo = currentVisibleTo.filter(uid => uid !== loggedInUser.uid);\n      if (newVisibleTo.length === 0) {\n        const chatRef = doc(db, \"chats\", chatId);\n        await updateDoc(chatRef, {\n          visibleTo: []\n        });\n      } else {\n        const chatRef = doc(db, \"chats\", chatId);\n        await updateDoc(chatRef, {\n          visibleTo: newVisibleTo\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Error hiding chat:\", error);\n      return false;\n    }\n  };\n  const leaveChat = async chatId => {\n    try {\n      const chatRef = doc(db, \"chats\", chatId);\n      const chatSnap = await getDoc(chatRef);\n      if (!chatSnap.exists()) return false;\n      const chatData = chatSnap.data();\n      const updatedParticipants = chatData.participants.filter(uid => uid !== loggedInUser.uid);\n      const updatedVisibleTo = chatData.visibleTo.filter(uid => uid !== loggedInUser.uid);\n      const updatedDetails = chatData.participantDetails.filter(p => p.uid !== loggedInUser.uid);\n      await updateDoc(chatRef, {\n        participants: updatedParticipants,\n        visibleTo: updatedVisibleTo,\n        participantDetails: updatedDetails\n      });\n      const systemMsgText = `${loggedInUser.playerName} left the group.`;\n      await addDoc(collection(db, \"chats\", chatId, \"messages\"), {\n        text: systemMsgText,\n        type: 'system',\n        createdAt: serverTimestamp()\n      });\n      await updateDoc(chatRef, {\n        lastMessage: systemMsgText,\n        lastMessageTime: new Date()\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error leaving chat:\", error);\n      return false;\n    }\n  };\n  const renameChat = async (chatId, newName) => {\n    try {\n      const chatRef = doc(db, \"chats\", chatId);\n      await updateDoc(chatRef, {\n        name: newName\n      });\n      return true;\n    } catch (error) {\n      console.error(\"Error renaming chat:\", error);\n      return false;\n    }\n  };\n  const value = {\n    myChats,\n    createChat,\n    sendMessage,\n    updateGroupPhoto,\n    addParticipant,\n    leaveChat,\n    hideChat,\n    renameChat,\n    markChatAsRead\n  };\n  return /*#__PURE__*/_jsxDEV(ChatContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 363,\n    columnNumber: 5\n  }, this);\n};\n_s2(ChatProvider, \"ksuwlp4pjLY8XP93S1KuoOTr7tw=\", false, function () {\n  return [useAuth];\n});\n_c = ChatProvider;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useCallback","collection","addDoc","updateDoc","doc","query","where","orderBy","onSnapshot","serverTimestamp","increment","getDocs","getDoc","arrayUnion","deleteField","db","useAuth","jsxDEV","_jsxDEV","ChatContext","useChat","_s","ChatProvider","children","_s2","loggedInUser","myChats","setMyChats","chatsRef","q","uid","unsubscribe","snapshot","chats","docs","map","id","data","error","console","markChatAsRead","chatId","chatRef","createChat","participantEmails","chatName","usersRef","participants","participantIds","push","name","playerName","email","photoURL","querySnapshot","empty","userDoc","userData","length","alert","existingChat","find","c","every","includes","visibleTo","initialUnread","forEach","docRef","type","participantDetails","unreadCounts","createdAt","lastMessage","lastMessageTime","Date","message","sendMessage","text","currentParticipants","imageUrl","senderId","senderName","summary","visibleToUpdate","updatePayload","unreadUpdates","updateGroupPhoto","systemMsgText","addParticipant","newEmail","includeHistory","newUser","chatSnap","chatData","updateData","hideChat","currentVisibleTo","newVisibleTo","filter","leaveChat","exists","updatedParticipants","updatedVisibleTo","updatedDetails","p","renameChat","newName","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/dbroxton/Documents/Projects/soccer-management-app/src/context/ChatContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';\nimport { \n  collection, addDoc, updateDoc, doc, \n  query, where, orderBy, onSnapshot, serverTimestamp, increment, \n  getDocs, getDoc, arrayUnion, deleteField \n} from \"firebase/firestore\"; \nimport { db } from \"../config/firebase\"; \nimport { useAuth } from './AuthContext';\n\nconst ChatContext = createContext();\n\nexport const useChat = () => {\n  return useContext(ChatContext);\n};\n\nexport const ChatProvider = ({ children }) => {\n  const { loggedInUser } = useAuth();\n  const [myChats, setMyChats] = useState([]);\n\n  // 1. GLOBAL LISTENER\n  useEffect(() => {\n    if (!loggedInUser) {\n      setMyChats([]);\n      return;\n    }\n\n    const chatsRef = collection(db, \"chats\");\n    const q = query(\n      chatsRef, \n      where(\"visibleTo\", \"array-contains\", loggedInUser.uid), \n      orderBy(\"lastMessageTime\", \"desc\")\n    );\n\n    const unsubscribe = onSnapshot(q, (snapshot) => {\n      const chats = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n      setMyChats(chats);\n    }, (error) => {\n      console.error(\"Error listening to chat list:\", error);\n    });\n\n    return () => unsubscribe();\n  }, [loggedInUser]);\n\n  // 2. MARK READ (Stabilized with useCallback)\n  const markChatAsRead = useCallback(async (chatId) => {\n    if (!loggedInUser) return;\n    try {\n      const chatRef = doc(db, \"chats\", chatId);\n      await updateDoc(chatRef, {\n        [`unreadCounts.${loggedInUser.uid}`]: 0\n      });\n    } catch (error) {\n      console.error(\"Error marking read:\", error);\n    }\n  }, [loggedInUser]);\n\n  // 3. CREATE CHAT\n  const createChat = async (participantEmails, chatName = \"\") => {\n    try {\n      const usersRef = collection(db, \"users\");\n      const participants = [];\n      const participantIds = [loggedInUser.uid];\n\n      // Add self\n      participants.push({\n        uid: loggedInUser.uid,\n        name: loggedInUser.playerName,\n        email: loggedInUser.email,\n        photoURL: loggedInUser.photoURL || \"\" \n      });\n\n      // Resolve other emails\n      for (const email of participantEmails) {\n        if (email === loggedInUser.email) continue; \n        const q = query(usersRef, where(\"email\", \"==\", email));\n        const querySnapshot = await getDocs(q);\n        \n        if (!querySnapshot.empty) {\n          const userDoc = querySnapshot.docs[0];\n          const userData = userDoc.data();\n          participantIds.push(userDoc.id);\n          participants.push({\n            uid: userDoc.id,\n            name: userData.playerName || \"Unknown\",\n            email: userData.email,\n            photoURL: userData.photoURL || \"\" \n          });\n        }\n      }\n\n      if (participantIds.length < 2) {\n        alert(\"Could not find any valid users to chat with.\");\n        return false;\n      }\n\n      // Check for existing\n      const existingChat = myChats.find(c => {\n        if (c.participants.length !== participantIds.length) return false;\n        return participantIds.every(id => c.participants.includes(id));\n      });\n\n      if (existingChat) {\n        const chatRef = doc(db, \"chats\", existingChat.id);\n        if (!existingChat.visibleTo.includes(loggedInUser.uid)) {\n           await updateDoc(chatRef, {\n             visibleTo: arrayUnion(loggedInUser.uid)\n           });\n        }\n        return { \n          id: existingChat.id, \n          participants: existingChat.participants,\n          name: existingChat.name, \n          ...existingChat\n        };\n      }\n\n      // Create New\n      const initialUnread = {};\n      participantIds.forEach(uid => initialUnread[uid] = 0);\n\n      const docRef = await addDoc(collection(db, \"chats\"), {\n        type: participantIds.length > 2 ? 'group' : 'dm',\n        name: chatName || (participants.length === 2 ? participants[1].name : \"Group Chat\"),\n        participants: participantIds,\n        visibleTo: participantIds,\n        participantDetails: participants,\n        unreadCounts: initialUnread,\n        createdAt: serverTimestamp(),\n        lastMessage: \"Chat created\",\n        lastMessageTime: new Date() \n      });\n      \n      return { id: docRef.id, participants: participantIds, participantDetails: participants }; \n\n    } catch (error) {\n      console.error(\"Error creating chat:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  // 4. SEND MESSAGE\n  const sendMessage = async (chatId, text, currentParticipants, imageUrl = null) => {\n    try {\n      await addDoc(collection(db, \"chats\", chatId, \"messages\"), {\n        text: text,\n        imageUrl: imageUrl,\n        senderId: loggedInUser.uid,\n        senderName: loggedInUser.playerName,\n        createdAt: serverTimestamp(),\n        type: 'text'\n      });\n\n      const chatRef = doc(db, \"chats\", chatId);\n      let summary = text;\n      if (imageUrl) {\n        summary = text ? `ðŸ“· ${text}` : \"ðŸ“· Sent an image\";\n      }\n\n      const visibleToUpdate = currentParticipants || [loggedInUser.uid];\n      const updatePayload = {\n        lastMessage: summary,\n        lastMessageTime: new Date(),\n        visibleTo: visibleToUpdate\n      };\n\n      const unreadUpdates = {};\n      if (currentParticipants) {\n        currentParticipants.forEach(uid => {\n          if (uid !== loggedInUser.uid) {\n            unreadUpdates[`unreadCounts.${uid}`] = increment(1);\n          }\n        });\n      }\n\n      await updateDoc(chatRef, { ...updatePayload, ...unreadUpdates });\n      return true;\n    } catch (error) {\n      console.error(\"Error sending message:\", error);\n      alert(\"Error: \" + error.message);\n      return false;\n    }\n  };\n\n  // 5. UPDATE GROUP PHOTO\n  const updateGroupPhoto = async (chatId, photoURL) => {\n    try {\n      const chatRef = doc(db, \"chats\", chatId);\n      await updateDoc(chatRef, { photoURL: photoURL });\n\n      const systemMsgText = `${loggedInUser.playerName} changed the group photo.`;\n      \n      await addDoc(collection(db, \"chats\", chatId, \"messages\"), {\n        text: systemMsgText,\n        type: 'system',\n        createdAt: serverTimestamp()\n      });\n\n      await updateDoc(chatRef, {\n        lastMessage: systemMsgText,\n        lastMessageTime: new Date()\n      });\n\n      return true;\n    } catch (error) {\n      console.error(\"Error updating group photo:\", error);\n      return false;\n    }\n  };\n\n  // 6. ADD PARTICIPANT\n  const addParticipant = async (chatId, newEmail, includeHistory) => {\n    try {\n        const usersRef = collection(db, \"users\");\n        const q = query(usersRef, where(\"email\", \"==\", newEmail));\n        const querySnapshot = await getDocs(q);\n\n        if (querySnapshot.empty) {\n            alert(\"User not found.\");\n            return false;\n        }\n\n        const userDoc = querySnapshot.docs[0];\n        const newUser = {\n            uid: userDoc.id,\n            name: userDoc.data().playerName || \"Unknown\",\n            email: userDoc.data().email,\n            photoURL: userDoc.data().photoURL || \"\"\n        };\n\n        const chatRef = doc(db, \"chats\", chatId);\n        const chatSnap = await getDoc(chatRef);\n        const chatData = chatSnap.data();\n\n        if (chatData.participants.includes(newUser.uid)) {\n            alert(\"User is already in the group.\");\n            return false;\n        }\n\n        // Basic Update\n        let updateData = {\n            participants: arrayUnion(newUser.uid),\n            visibleTo: arrayUnion(newUser.uid),\n            participantDetails: arrayUnion(newUser),\n            [`unreadCounts.${newUser.uid}`]: 0\n        };\n\n        if (!includeHistory) {\n             // Hide history -> Set timestamp\n             updateData[`hiddenHistory.${newUser.uid}`] = serverTimestamp();\n        } else {\n             // Show history -> EXPLICITLY DELETE any old restriction\n             updateData[`hiddenHistory.${newUser.uid}`] = deleteField();\n        }\n\n        // 1. Update Chat Doc\n        await updateDoc(chatRef, updateData);\n\n        // 2. Add System Message\n        const systemMsgText = `${loggedInUser.playerName} added ${newUser.name} to the group.`;\n        await addDoc(collection(db, \"chats\", chatId, \"messages\"), {\n            text: systemMsgText,\n            type: 'system',\n            createdAt: serverTimestamp()\n        });\n\n        // 3. Update Last Message\n        await updateDoc(chatRef, {\n            lastMessage: systemMsgText,\n            lastMessageTime: new Date()\n        });\n\n        return true;\n    } catch (error) {\n        console.error(\"Error adding participant:\", error);\n        alert(\"Error adding user: \" + error.message);\n        return false;\n    }\n  };\n\n  // 7. LEAVE/HIDE CHAT\n  const hideChat = async (chatId, currentVisibleTo) => {\n    try {\n      const newVisibleTo = currentVisibleTo.filter(uid => uid !== loggedInUser.uid);\n      if (newVisibleTo.length === 0) {\n        const chatRef = doc(db, \"chats\", chatId);\n        await updateDoc(chatRef, { visibleTo: [] });\n      } else {\n        const chatRef = doc(db, \"chats\", chatId);\n        await updateDoc(chatRef, { visibleTo: newVisibleTo });\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Error hiding chat:\", error);\n      return false;\n    }\n  };\n\n  const leaveChat = async (chatId) => {\n    try {\n      const chatRef = doc(db, \"chats\", chatId);\n      const chatSnap = await getDoc(chatRef);\n      if (!chatSnap.exists()) return false;\n\n      const chatData = chatSnap.data();\n      \n      const updatedParticipants = chatData.participants.filter(uid => uid !== loggedInUser.uid);\n      const updatedVisibleTo = chatData.visibleTo.filter(uid => uid !== loggedInUser.uid);\n      const updatedDetails = chatData.participantDetails.filter(p => p.uid !== loggedInUser.uid);\n\n      await updateDoc(chatRef, {\n        participants: updatedParticipants,\n        visibleTo: updatedVisibleTo,\n        participantDetails: updatedDetails\n      });\n\n      const systemMsgText = `${loggedInUser.playerName} left the group.`;\n      await addDoc(collection(db, \"chats\", chatId, \"messages\"), {\n        text: systemMsgText,\n        type: 'system',\n        createdAt: serverTimestamp()\n      });\n      \n      await updateDoc(chatRef, {\n        lastMessage: systemMsgText,\n        lastMessageTime: new Date()\n      });\n\n      return true;\n    } catch (error) {\n      console.error(\"Error leaving chat:\", error);\n      return false;\n    }\n  };\n\n  const renameChat = async (chatId, newName) => {\n    try {\n      const chatRef = doc(db, \"chats\", chatId);\n      await updateDoc(chatRef, { name: newName });\n      return true;\n    } catch (error) {\n      console.error(\"Error renaming chat:\", error);\n      return false;\n    }\n  };\n\n  const value = {\n    myChats,\n    createChat,\n    sendMessage,\n    updateGroupPhoto,\n    addParticipant,\n    leaveChat,\n    hideChat,\n    renameChat,\n    markChatAsRead\n  };\n\n  return (\n    <ChatContext.Provider value={value}>\n      {children}\n    </ChatContext.Provider>\n  );\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}